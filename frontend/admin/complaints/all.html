<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/admin.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <style>
    .priority-severe { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .priority-moderate { background-color: #ffc107; color: black; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .priority-minor { background-color: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    /* Uniform table row styling with consistent row heights */
    .complaints-table tbody tr { 
      min-height: 70px; 
      height: 70px;
    }
    .complaints-table tbody td { 
      padding: 12px 8px; 
      vertical-align: middle; 
      word-wrap: break-word; 
      line-height: 1.4;
      max-height: 70px;
      overflow: hidden;
    }
    /* Center align all table contents and adjust column widths */
    .complaints-table th, .complaints-table td { text-align: center; }
    .complaints-table th:nth-child(2), .complaints-table td:nth-child(2) { min-width: 150px; width: 150px; } /* Complainant */
    .complaints-table th:nth-child(4), .complaints-table td:nth-child(4) { min-width: 140px; width: 140px; } /* HOA - increased width */
    .complaints-table th:nth-child(5), .complaints-table td:nth-child(5) { min-width: 140px; width: 140px; } /* Assigned To */
    .complaints-table th:nth-child(7), .complaints-table td:nth-child(7) { min-width: 140px; width: 140px; } /* Action Needed - reduced width */
    /* Status-based row colors - higher specificity */
    .complaints-table tbody tr.status-pending { background-color: #FFE6A7 !important; cursor: pointer; }
    .complaints-table tbody tr.status-pending:hover { background-color: #FFD980 !important; }
    .complaints-table tbody tr.status-inspection { background-color: #A7D8F2 !important; cursor: pointer; }
    .complaints-table tbody tr.status-inspection:hover { background-color: #85C7ED !important; }
    .complaints-table tbody tr.status-invitation { background-color: #a6a5ff !important; cursor: pointer; }
    .complaints-table tbody tr.status-invitation:hover { background-color: #8D8CFF !important; }
    .complaints-table tbody tr.status-mediation { background-color: #C9B6E4 !important; cursor: pointer; }
    .complaints-table tbody tr.status-mediation:hover { background-color: #B8A1D9 !important; }
    .complaints-table tbody tr.status-assessment { background-color: #B5E48C !important; cursor: pointer; }
    .complaints-table tbody tr.status-assessment:hover { background-color: #A0DB70 !important; }
    .complaints-table tbody tr.status-invalid { background-color: #F6B6B6 !important; cursor: pointer; }
    .complaints-table tbody tr.status-invalid:hover { background-color: #F19999 !important; }
    .complaints-table tbody tr.status-assigned { background-color: #9FE2BF !important; cursor: pointer; }
    .complaints-table tbody tr.status-assigned:hover { background-color: #7DDBA8 !important; }
    .complaints-table tbody tr.status-unresolved { background-color: #D3D3D3 !important; cursor: pointer; }
    .complaints-table tbody tr.status-unresolved:hover { background-color: #C0C0C0 !important; }
    .complaints-table tbody tr.status-out-of-jurisdiction { background-color: #F6B6B6 !important; cursor: pointer; }
    .complaints-table tbody tr.status-out-of-jurisdiction:hover { background-color: #F19999 !important; }
    .complaints-table tbody tr:hover { cursor: pointer; }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/admin/dashboard" class="nav-item">Map</a>
      <a href="/admin/complaints/all.html" class="nav-item active">Complaints</a>
      <a href="/admin/database/beneficiaries.html" class="nav-item">Beneficiaries</a>
      <a href="/admin/database/policies.html" class="nav-item">Policies</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <div class="main-content">
    <div class="complaints-header" style="display: flex; justify-content: space-between; align-items: center;">
      <h1>Complaints</h1>

      <!-- Inbox Dropdown -->
      <div class="inbox-dropdown" style="position: relative;">
        <button id="inboxBtn" style="
          background: none; 
          border: none; 
          cursor: pointer; 
          position: relative;
          font-size: 22px;
          color: #1a33a0;
        ">
          <i class="bi bi-bell-fill"></i>
          <span id="notifCount" style="
            position: absolute;
            top: -5px;
            right: -8px;
            background: red;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
          ">0</span>
        </button>

        <div id="inboxMenu" style="
          display: none;
          position: absolute;
          top: 36px;
          right: 0;
          background: white;
          border: 1px solid #ccc;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          width: 280px;
          max-height: 300px;
          overflow-y: auto;
          z-index: 1000;
        ">
          <div id="inboxList" style="padding: 10px;">
            <p style="margin: 0; font-size: 14px; color: #666;">No due complaints.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Stats -->
    <div class="stats">
      <div class="stat-card">
        <i class="bi bi-graph-up-arrow"></i>
        <div>
          <h2>0</h2>
          <p>Complaints</p>
        </div>
      </div>
      
      <div class="stat-card">
        <i class="bi bi-person-exclamation"></i>
        <div>
          <h2>0</h2>
          <p>On Going</p>   
        </div>
      </div>
      
      <div class="stat-card">
        <i class="bi bi-person-x"></i>
        <div>
         <h2>0</h2>
          <p>Unresolved</p>
        </div>
      </div>
    </div>
        
    <!-- Tabs -->
    <div class="tabs" style="display: flex; justify-content: space-between; align-items: center;">
  <div>
    <a href="all.html" class="active"> All</a>
    <a href="pending.html">Received</a>
    <a href="ongoing.html">On Going</a>
    <a href="resolved.html">Resolved</a>
    <a href="invalid.html">Out of Jurisdiction</a>
    <a href="unresolved.html">Unresolved</a>
  </div>

  <div style="display: flex; align-items: center; gap: 10px;">
    <input type="month" id="reportMonthPicker" style="padding: 6px; border-radius: 4px;">
    <button id="generateReportBtn" class="btn btn-danger">
      <i class="bi bi-file-earmark-pdf"></i> Generate Report
    </button>
  </div>
</div>

    <!-- Table -->
    <div class="table-container">
    <table class="complaints-table">
      <thead>
        <tr>
          <th style="text-align: center;">ID No.</th> <!-- Future format: MMDDYY-ID (e.g., 100825-123) -->
          <th class="date-submitted" style="position: relative; text-align: center;">
          Date Submitted 
          <i class="bi bi-caret-down-fill" id="dateDropdownToggle" 
            style="font-size: 12px; color: gray; cursor: pointer; margin-left: 4px;"></i>

          <div id="dateDropdownMenu" 
              style="display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
                      background: white; border: 1px solid #ccc; border-radius: 4px; z-index: 999; width: 140px;
                      box-shadow: 0 2px 5px rgba(0,0,0,0.15);">
          </div>
        </th>

          <th style="text-align: center;">Complainant</th>
          <th class="type-of-complaint" style="position: relative; text-align: center;">
            Complaint Type
            <i class="bi bi-caret-down-fill" id="typeDropdownToggle" 
               style="cursor: pointer; font-size: 12px; margin-left: 5px; color: #666;"></i>
            <div id="typeDropdownMenu" 
                 style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc; z-index: 1000; min-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);"></div>
          </th>
          <th style="text-align: center;">HOA</th>
          <th class="assigned-to" style="position: relative; text-align: center;">
            Assigned To 
            <i class="bi bi-caret-down-fill" id="assignedDropdownToggle" 
               style="cursor: pointer; font-size: 12px; margin-left: 5px; color: #666;"></i>
            <div id="assignedDropdownMenu" 
                 style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc; z-index: 1000; min-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);"></div>
          </th>
          <th style="text-align: center;">Status</th>
          <th style="text-align: center;">Stage of Action</th>
          <th class="priority-level" style="position: relative; text-align: center;">
            Priority Level 
            <i class="bi bi-caret-down-fill" id="priorityDropdownToggle" 
               style="cursor: pointer; font-size: 12px; margin-left: 5px; color: #666;"></i>
            <div id="priorityDropdownMenu" 
                 style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc; z-index: 1000; min-width: 150px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);"></div>
          </th>
        </tr>
      </thead>
        
      <tbody id="complaints-table-body">
        <!-- Dynamic data will be loaded here -->
      </tbody>
    </table>
    </div>
  </div>


  <script>
    // Global variable to store all complaints data for sorting
    let allComplaintsData = [];

    // Load all complaints data
    async function loadAllComplaints() {
      try {
        const response = await fetch(`/admin/complaints/api/all?_=${Date.now()}`);
        const data = await response.json();
        
        if (Array.isArray(data)) {
          allComplaintsData = data;
          populateTable(data);
        } else if (data.success && data.complaints) {
          allComplaintsData = data.complaints;
          populateTable(data.complaints);
        } else {
          console.error('Failed to load complaints:', data.message || 'Unknown error');
        }
      } catch (error) {
        console.error('Error loading complaints:', error);
      }
    }

    // Load admin statistics
    async function loadStats() {
      try {
        const [statsResponse, unresolvedResponse] = await Promise.all([
          fetch(`/admin/complaints/api/stats?_=${Date.now()}`),
          fetch(`/admin/complaints/api/unresolved?_=${Date.now()}`)
        ]);
        
        const statsData = await statsResponse.json();
        const unresolvedData = await unresolvedResponse.json();
        
        if (statsData.total !== undefined) {
          document.querySelector('.stat-card:nth-child(1) h2').textContent = statsData.total || 0;
          document.querySelector('.stat-card:nth-child(2) h2').textContent = statsData.ongoing || 0;
        }
        
        // Count unresolved from dedicated endpoint
        const unresolvedCount = Array.isArray(unresolvedData) ? unresolvedData.length : 
                               (unresolvedData.complaints ? unresolvedData.complaints.length : 0);
        document.querySelector('.stat-card:nth-child(3) h2').textContent = unresolvedCount;
        
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    }

    // Populate the table with complaint data
    function populateTable(complaints) {
      const tbody = document.getElementById('complaints-table-body');
      tbody.innerHTML = '';
      
      if (complaints.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">No complaints found</td></tr>';
        return;
      }
      
      complaints.forEach(complaint => {
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        
        row.addEventListener('click', () => {
          const detailsPage = complaint.status === 'Invalid' ? 'complaint_details_invalid.html' : 'complaint_details_valid.html';
          window.location.href = `/admin/complaints/${detailsPage}?id=${complaint.complaint_id}&referrer=all.html`;
        });
        
        // Calculate status with deadline countdown - using EXACT same logic as index.html adminGetDeadlineDate
        const calculateStatusWithDeadline = (complaint) => {
          if (complaint.status === 'Invalid') return '<em>N/A</em>';
          if (complaint.complaint_stage === 'Resolved') return '';
          if (complaint.complaint_stage === 'Unresolved') return '';
          if (complaint.complaint_stage === 'Out of Jurisdiction') return '';
          if (complaint.complaint_stage === 'Pending' || !complaint.latest_action) return '<em>Received</em>';
          
          // For ongoing complaints, calculate deadline using index.html logic
          if (!complaint.action_datetime) return complaint.complaint_stage || 'Ongoing';
          
          const actionDate = new Date(complaint.action_datetime);
          const actionType = (complaint.latest_action || '').toLowerCase();
          
          // Get admin-set deadline for inspection from complaint history/actions
          let adminDeadline = null;
          if (complaint.deadline) {
            console.log(`Complaint ${complaint.complaint_id}: Using admin deadline ${complaint.deadline}`);
            adminDeadline = new Date(complaint.deadline);
          } else {
            console.log(`Complaint ${complaint.complaint_id}: No admin deadline found`);
          }
          
          // Get meeting datetime from invitation action
          let meetingDateTime = null;
          if (complaint.meeting_datetime && complaint.meeting_datetime !== 'null' && complaint.meeting_datetime !== null) {
            meetingDateTime = new Date(complaint.meeting_datetime);
            console.log(`[STATUS] Complaint ${complaint.complaint_id}: using meeting_datetime = ${meetingDateTime}`);
          } else if (complaint.meeting_date && complaint.meeting_time && 
                     complaint.meeting_date !== 'null' && complaint.meeting_date !== null &&
                     complaint.meeting_time !== 'null' && complaint.meeting_time !== null) {
            meetingDateTime = new Date(`${complaint.meeting_date}T${complaint.meeting_time}`);
            console.log(`[STATUS] Complaint ${complaint.complaint_id}: constructed meetingDateTime from date+time = ${meetingDateTime}`);
          } else {
            console.log(`[STATUS] Complaint ${complaint.complaint_id}: no meeting data found in top-level fields`);
            console.log(`[STATUS] Available fields:`, {
              meeting_datetime: complaint.meeting_datetime,
              meeting_date: complaint.meeting_date,
              meeting_time: complaint.meeting_time
            });
            console.log(`[STATUS] Full complaint object keys:`, Object.keys(complaint));
            console.log(`[STATUS] Details field:`, complaint.details);
            console.log(`[STATUS] complaint_history field:`, complaint.complaint_history);
            
            // Check if there are nested details that might contain meeting info
            if (complaint.details) {
              console.log(`[STATUS] Found details field:`, complaint.details);
              try {
                const detailsObj = typeof complaint.details === 'string' ? JSON.parse(complaint.details) : complaint.details;
                if (detailsObj.meeting_date && detailsObj.meeting_time) {
                  meetingDateTime = new Date(`${detailsObj.meeting_date}T${detailsObj.meeting_time}`);
                  console.log(`[STATUS] Found meeting data in details: ${meetingDateTime}`);
                }
              } catch (e) {
                console.log(`[STATUS] Error parsing details:`, e);
              }
            }
          }
          
          // Calculate deadline based on action type (EXACT same logic as index.html)
          let deadline = null;
          
          if (actionType.includes('inspection') && !actionType.includes('done')) {
            deadline = adminDeadline || new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('inspection done')) {
            deadline = new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('send invitation') || (actionType.includes('invitation') && !actionType.includes('sent') && !actionType.includes('accepted'))) {
            deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('sent invitation')) {
            deadline = new Date(actionDate.getTime() + (20 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('accepted invitation')) {
            // For accepted invitation, ONLY use meeting_date from invitation details
            if (meetingDateTime && !isNaN(meetingDateTime.getTime())) {
              deadline = meetingDateTime;
              console.log(`[STATUS] Complaint ${complaint.complaint_id}: using meeting deadline = ${deadline}`);
            } else {
              console.warn(`[STATUS] Complaint ${complaint.complaint_id}: no valid meeting_date for accepted invitation`);
              return 'Missing meeting date';
            }
          } else if (actionType.includes('mediation')) {
            const baseDate = meetingDateTime || actionDate;
            deadline = new Date(baseDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('assessment')) {
            // Assessment has no deadline - ready for resolution
            return 'Assessment Complete';
          } else {
            deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
          }
          
          // If no deadline calculated, return stage
          if (!deadline) return complaint.complaint_stage || 'Ongoing';
          
          const now = new Date();
          
          // Normalize dates to compare only the date part (ignore time) - same logic as index.html
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
          const deadlineDate = new Date(deadline.getFullYear(), deadline.getMonth(), deadline.getDate(), 0, 0, 0, 0);
          
          const timeDiff = deadlineDate.getTime() - today.getTime();
          const daysDiff = Math.round(timeDiff / (1000 * 3600 * 24));
          
          let status = complaint.complaint_stage || 'Ongoing';
          let countdown = '';
          
          if (daysDiff < 0) {
            status = 'Overdue';
            countdown = `<br/><small style="color: red; font-weight: bold; font-size: 11px">${Math.abs(daysDiff)} day/s late</small>`;
          } else if (daysDiff === 0) {
            countdown = '<br/><small style="color: orange; font-weight: bold;">Due today</small>';
          } else {
            countdown = `<br/><small style="color: green;">${daysDiff} day/s left</small>`;
          }
          
          return status + countdown;
        };
        
        // Handle different complaint states
        let assignedToDisplay, statusDisplay, actionNeededDisplay;
        
        if (complaint.status === 'Invalid') {
          assignedToDisplay = '<em>N/A</em>';
          statusDisplay = '<em>N/A</em>';
          actionNeededDisplay = 'Invalid';
        } else if (complaint.complaint_stage === 'Out of Jurisdiction') {
          assignedToDisplay = '<em>N/A</em>';
          statusDisplay = 'Out of Jurisdiction';
          actionNeededDisplay = 'Out of Jurisdiction';
        } else if (complaint.complaint_stage === 'Unresolved') {
          assignedToDisplay = complaint.assigned_to || 'N/A';
          statusDisplay = 'Unresolved';
          actionNeededDisplay = complaint.latest_action || 'Unresolved';
        } else if (complaint.complaint_stage === 'Resolved') {
          assignedToDisplay = complaint.assigned_to || 'N/A';
          statusDisplay = 'Resolved';
          actionNeededDisplay = complaint.latest_action || 'Resolved';
        } else if (complaint.complaint_stage === 'Pending' || !complaint.latest_action) {
          assignedToDisplay = 'Pending';
          statusDisplay = '<em>Received</em>';
          actionNeededDisplay = complaint.latest_action || 'Received';
        } else {
          assignedToDisplay = complaint.assigned_to || 'N/A';
          statusDisplay = calculateStatusWithDeadline(complaint);
          actionNeededDisplay = complaint.latest_action || 'Received';
        }
        
        row.innerHTML = `
          <td>${complaint.complaint_id}</td>
          <td>${formatDateWithTimestamp(complaint.date_received)}</td>
          <td>${complaint.complainant_name || complaint.complainant || 'N/A'}</td>
          <td>${complaint.type_of_complaint}</td>
          <td>${complaint.area_name}</td>
          <td>${assignedToDisplay}</td>
          <td>${statusDisplay}</td>
          <td>${actionNeededDisplay}</td>
          <td><button class="priority-${(complaint.priority_level || 'minor').toLowerCase()}">${complaint.priority_level || 'Minor'}</button></td>
        `;
        
        // Add status-based styling AFTER setting innerHTML
        console.log('Complaint data:', complaint); // Debug log
        if (complaint.status === 'Invalid') {
          row.classList.add('status-invalid');
          row.style.backgroundColor = '#F6B6B6'; // Fallback inline style
          console.log('Applied status-invalid class');
        } else if (complaint.complaint_stage === 'Pending') {
          row.classList.add('status-pending');
          row.style.backgroundColor = '#FFE6A7'; // Fallback inline style
          console.log('Applied status-pending class');
        } else if (complaint.complaint_stage === 'Ongoing') {
          // Apply styling based on action needed - whole row gets colored
          const actionNeeded = (complaint.action_needed || complaint.latest_action || '').toLowerCase();
          if (actionNeeded.includes('inspection')) {
            row.classList.add('status-inspection');
            row.style.backgroundColor = '#A7D8F2'; // Light blue for inspection/inspection done
            console.log('Applied status-inspection class');
          } else if (actionNeeded.includes('invitation')) {
            row.classList.add('status-invitation');
            row.style.backgroundColor = '#9FE2BF'; // Light green for invitation/sent invitation
            console.log('Applied status-invitation class');
          } else if (actionNeeded.includes('mediation')) {
            row.classList.add('status-mediation');
            row.style.backgroundColor = '#C9B6E4'; // Light purple for mediation
            console.log('Applied status-mediation class');
          } else if (actionNeeded.includes('assessment')) {
            row.classList.add('status-assessment');
            row.style.backgroundColor = '#B5E48C'; // Light green for assessment
            console.log('Applied status-assessment class');
          }
        } else if (complaint.complaint_stage === 'Out of Jurisdiction') {
          row.classList.add('status-out-of-jurisdiction');
          row.style.backgroundColor = '#F6B6B6'; // Same color as invalid.html
          console.log('Applied status-out-of-jurisdiction class');
        } else if (complaint.complaint_stage === 'Unresolved') {
          row.classList.add('status-unresolved');
          row.style.backgroundColor = '#D3D3D3'; // Light gray for unresolved
          console.log('Applied status-unresolved class');
        } else if (complaint.assigned_to) {
          row.classList.add('status-assigned');
          row.style.backgroundColor = '#FFD6A5'; // Fallback inline style
          console.log('Applied status-assigned class');
        }
        
        tbody.appendChild(row);
      });
    }



    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      loadAllComplaints();
      loadStats();
    });
  </script>

  <script>
    // Enhanced deadline calculation based on specific action types
    function formatDeadline(complaint) {
      // Check if complaint is in final state - no deadline needed
      if (complaint.complaint_stage === 'Resolved' || 
          complaint.complaint_stage === 'Unresolved' || 
          complaint.complaint_stage === 'Out of Jurisdiction') {
        return 'Final';
      }
      
      if (!complaint.action_datetime) return 'N/A';
      
      const actionType = (complaint.latest_action || complaint.action_needed || '').toLowerCase();
      const actionDate = new Date(complaint.action_datetime);
      
      // Get admin-set deadline for inspection from complaint history/actions
      let adminDeadline = null;
      if (complaint.deadline) {
        adminDeadline = new Date(complaint.deadline);
      }
      
      // Get meeting datetime from invitation action in complaint history
      let meetingDateTime = null;
      if (complaint.meeting_date && complaint.meeting_time) {
        // Construct meeting datetime from separate date and time fields
        meetingDateTime = new Date(`${complaint.meeting_date}T${complaint.meeting_time}`);
      }

      if (actionType.includes('inspection') && !actionType.includes('done')) {
        // Inspection → Deadline = 'Deadline' date set by admin + time when Inspection action was saved
        if (adminDeadline) {
          const dateStr = adminDeadline.toLocaleDateString();
          const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          return `${dateStr}<br/>${timeStr}`;
        }
        // Fallback to 3 days if no admin deadline set
        const deadline = new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
        const dateStr = deadline.toLocaleDateString();
        const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        return `${dateStr}<br/>${timeStr}`;
      }
      
      else if (actionType.includes('inspection done')) {
        // Inspection done → Show "Send invite before:" + 3 days after this action
        const deadline = new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
        const dateStr = deadline.toLocaleDateString();
        return `Send invite before:<br/>${dateStr}`;
      }
      
      else if (actionType.includes('send invitation') || actionType.includes('invitation') && !actionType.includes('sent') && !actionType.includes('accepted')) {
        // Send Invitation → 1 day after the previous action
        const deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
        const dateStr = deadline.toLocaleDateString();
        const timeStr = deadline.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        return `${dateStr}<br/>${timeStr}`;
      }
      
      else if (actionType.includes('sent invitation')) {
        // Sent Invitation → 20 days after the previous action
        const deadline = new Date(actionDate.getTime() + (20 * 24 * 60 * 60 * 1000));
        const dateStr = deadline.toLocaleDateString();
        const timeStr = deadline.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        return `${dateStr}<br/>${timeStr}`;
      }
      
      else if (actionType.includes('accepted invitation')) {
        // Accepted Invitation → Use meeting_date from Invitation details as the deadline
        if (meetingDateTime && !isNaN(meetingDateTime.getTime())) {
          const dateStr = meetingDateTime.toLocaleDateString();
          const timeStr = meetingDateTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          return `${dateStr} | ${timeStr}<br/>(Mediation day)`;
        }
        // Fallback if no meeting datetime available
        console.warn(`No meeting_date found for complaint ${complaint.complaint_id} with accepted invitation`);
        const dateStr = actionDate.toLocaleDateString();
        return `${dateStr}<br/>(Mediation day)`;
      }
      
      else if (actionType.includes('mediation')) {
        // Mediation → "Make assessment before:" + 3 days after Date/Time of Meeting
        let baseDate = meetingDateTime || actionDate;
        const deadline = new Date(baseDate.getTime() + (3 * 24 * 60 * 60 * 1000));
        const dateStr = deadline.toLocaleDateString();
        return `Assess before:<br/>${dateStr}`;
      }
      
      else if (actionType.includes('assessment')) {
        // Assessment → "Mark as Resolved" in italic
        return `<em>Mark as Resolved</em>`;
      }
      
      // Default fallback
      const deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
      const dateStr = deadline.toLocaleDateString();
      const timeStr = deadline.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      return `${dateStr}<br/>${timeStr}`;
    }

    function calculatePendingDeadline(complaint) {
      // Use admin-set deadline if available
      if (complaint.deadline) {
        const deadlineDate = new Date(complaint.deadline);
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
        const normalizedDeadline = new Date(deadlineDate.getFullYear(), deadlineDate.getMonth(), deadlineDate.getDate(), 0, 0, 0, 0);
        
        const timeDiff = normalizedDeadline.getTime() - today.getTime();
        const daysDiff = Math.round(timeDiff / (1000 * 3600 * 24));
        
        const dateStr = deadlineDate.toLocaleDateString();

        if (daysDiff < 0) {
          return `${dateStr} (Overdue by ${Math.abs(daysDiff)}d)`;
        } else if (daysDiff === 0) {
          return `${dateStr} (Due today)`;
        } else if (daysDiff <= 2) {
          return `${dateStr} (${daysDiff}d left)`;
        } else {
          return `${dateStr} (${daysDiff}d left)`;
        }
      }
      
      // Fallback to 7 days from submission for pending complaints
      const submittedDate = new Date(complaint.date_received);
      
      // Calculate the actual deadline date (7 days from submission)
      const deadlineDate = new Date(submittedDate.getTime() + (7 * 24 * 60 * 60 * 1000));
      
      // Normalize dates to compare only the date part (ignore time) - same logic as assigned.html
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
      const normalizedDeadline = new Date(deadlineDate.getFullYear(), deadlineDate.getMonth(), deadlineDate.getDate(), 0, 0, 0, 0);
      
      const timeDiff = normalizedDeadline.getTime() - today.getTime();
      const daysDiff = Math.round(timeDiff / (1000 * 3600 * 24));
      
      const dateStr = deadlineDate.toLocaleDateString();

      if (daysDiff < 0) {
        return `${dateStr} (Overdue by ${Math.abs(daysDiff)}d)`;
      } else if (daysDiff === 0) {
        return `${dateStr} (Due today)`;
      } else if (daysDiff <= 2) {
        return `${dateStr} (${daysDiff}d left)`;
      } else {
        return `${dateStr} (${daysDiff}d left)`;
      }
    }

    // Report generation
    async function generateReport() {
      try {
        const monthPicker = document.getElementById("reportMonthPicker");
        const selectedMonth = monthPicker.value; 

        if (!selectedMonth) {
          alert("Please select a month first.");
          return;
        }

        // Fetch all complaints
        const response = await fetch(`/admin/complaints/api/all?_=${Date.now()}`);
        const data = await response.json();
        const complaints = Array.isArray(data) ? data : data.complaints || [];

        // Filter by month and year
        const [year, month] = selectedMonth.split("-").map(Number);
        const filteredComplaints = complaints.filter(c => {
          if (!c.date_received) return false;
          const date = new Date(c.date_received);
          return date.getFullYear() === year && date.getMonth() + 1 === month;
        });

        if (!filteredComplaints.length) {
          alert("No complaints found for the selected month.");
          return;
        }

        // Initialize jsPDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('landscape');

        // Title & Date
        const monthNames = [
          "January","February","March","April","May","June",
          "July","August","September","October","November","December"
        ];
        const monthYear = `${monthNames[month - 1]} ${year}`;
        const now = new Date();
        const formattedDate = now.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        const formattedTime = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

        doc.setFontSize(16);
        doc.text(`Complaints Report - ${monthYear}`, 14, 15);
        doc.setFontSize(10);
        doc.text(`Generated on: ${formattedDate}, ${formattedTime}`, 14, 22);

        // Fetch narrative summary for the selected month/year
        let narrative = '';
        try {
          const params = new URLSearchParams();
          params.append('year', String(year));
          params.append('month', String(month));
          const res = await fetch(`/admin/complaints/api/report_summary?${params.toString()}`);
          if (res.ok) {
            const payload = await res.json();
            if (payload && payload.success && payload.narrative) {
              narrative = payload.narrative;
            }
          }
        } catch (e) {
          console.warn('Failed to load report summary narrative', e);
        }

        // Prepare helpers for PDF-friendly formatting
        const sanitizeForPdf = (s) => (s || '')
          .replace(/<br\s*\/?>/gi, ' ')
          .replace(/<[^>]+>/g, '')
          .replace(/\s+/g, ' ')
          .trim();

        const getMeetingDateTime = (c) => {
          if (c.meeting_datetime) return new Date(c.meeting_datetime);
          if (c.meeting_date && c.meeting_time) return new Date(`${c.meeting_date}T${c.meeting_time}`);
          return null;
        };
        // Only consider explicit deadlines for PDF (no automatic fallbacks):
        // - Inspection: use admin-set deadline only
        // - Accepted invitation: use meeting date/time
        // - Mediation: optional derived from meeting date (+3 days) if you want, else comment out
        const explicitDeadlineForPdf = (c) => {
          if (!c || c.status === 'Invalid') return null;
          // Prefer explicit admin-set deadline when available
          if (c.deadline) {
            try {
              let d = new Date(c.deadline);
              if (isNaN(d.getTime())) d = new Date(`${c.deadline}T00:00:00`);
              if (!isNaN(d.getTime())) return d;
            } catch (e) { /* ignore */ }
          }
          // Otherwise show explicit meeting schedule if present
          const meetingDT = getMeetingDateTime(c);
          if (meetingDT) return meetingDT;
          return null;
        };

        // Prepare helpers and compute statistics for report
        const formatDateOnly = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const formatTimeOnly = (d) => d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        const computeStatusForPdf = (c) => {
          if (!c) return 'N/A';
          // Unresolved markers
          if (
            c.action_needed === 'Unresolved' ||
            c.latest_action === 'Unresolved' ||
            c.complaint_stage === 'Unresolved' ||
            c.is_unresolved
          ) return 'Unresolved';
          // Invalid maps to Out of Jurisdiction in report wording
          if (c.status === 'Invalid') return 'Out of Jurisdiction';
          if (c.complaint_stage === 'Resolved' || c.is_resolved) return 'Resolved';
          if (c.complaint_stage === 'Pending' || !c.latest_action) return 'Received';
          return 'Ongoing';
        };

        // === Improved Report Layout & Styling ===

// Descriptive Summary
const summaryText = narrative || `No descriptive summary available for ${monthYear}.`;

const totalComplaints = filteredComplaints.length;
const countsByType = {};
const countsByStatus = { 'Resolved': 0, 'Unresolved': 0, 'Ongoing': 0, 'Out of Jurisdiction': 0, 'Received': 0 };
filteredComplaints.forEach(c => {
  const t = c.type_of_complaint || 'Unknown';
  countsByType[t] = (countsByType[t] || 0) + 1;
  const s = computeStatusForPdf(c);
  if (s in countsByStatus) countsByStatus[s] += 1; else countsByStatus['Ongoing'] += 1;
});

// Overdue Ongoing Complaints
const nowTs = new Date().getTime();
const overdueOngoing = filteredComplaints.filter(c => {
  const s = computeStatusForPdf(c);
  if (s !== 'Ongoing') return false;
  const d = explicitDeadlineForPdf(c);
  if (!d) return false;
  return (new Date(d).getTime() - nowTs) < 0;
}).map(c => ({
  id: c.complaint_id,
  type: c.type_of_complaint || 'N/A',
  assigned: c.assigned_to || 'Unassigned',
  deadline: explicitDeadlineForPdf(c),
  submitted: c.date_received || null,
  hoa: c.area_name || ''
}));

// ======= SECTION 1: DESCRIPTIVE SUMMARY =======
doc.setFontSize(14);
doc.setTextColor(26, 51, 160);
doc.text('Descriptive Summary', 14, 30);
doc.setTextColor(0, 0, 0);
doc.setFontSize(10);

const pageWidth = doc.internal.pageSize.getWidth();
const marginX = 14;
const maxWidth = pageWidth - marginX * 2;
const summaryLines = doc.splitTextToSize(summaryText, maxWidth);
doc.text(summaryLines, marginX, 38);

let currentY = 28 + summaryLines.length * 5 + 10;

// ======= TABLE 1 & 2 SIDE BY SIDE =======

// Prepare data
const orderedTypes = ['Boundary Dispute', 'Lot Dispute', 'Pathway Dispute', 'Unauthorized Occupation'];
const breakdownRows = orderedTypes.map(t => [t, String(countsByType[t] || 0)]);
breakdownRows.push(['Total Complaints', String(totalComplaints)]);

const statusRows = [
  ['Resolved', String(countsByStatus['Resolved'] || 0)],
  ['Unresolved', String(countsByStatus['Unresolved'] || 0)],
  ['Ongoing', String(countsByStatus['Ongoing'] || 0)],
  ['Out of Jurisdiction', String(countsByStatus['Out of Jurisdiction'] || 0)],
  ['Received', String(countsByStatus['Received'] || 0)],
];

// Common dimensions - use printable width halves so tables are wider (match graphs)
const gapBetweenTables = 12;
const totalPrintable = pageWidth - marginX * 2;
const tableWidth = (totalPrintable - gapBetweenTables) / 2; // each table width
const col1Width = tableWidth * 0.7;
const col2Width = tableWidth * 0.3;
const startXLeft = marginX;
const startXRight = marginX + tableWidth + gapBetweenTables;

// ===== LEFT TABLE: Complaint Type =====
doc.autoTable({
  head: [['Complaint Type', 'Count']],
  body: breakdownRows,
  startY: currentY,
  theme: 'grid',
  styles: {
    fontSize: 9,
    cellPadding: 2.8,
    halign: 'left',
    lineWidth: 0.2,
    lineColor: [0, 0, 0],
  },
  tableWidth: tableWidth,
  margin: { left: startXLeft, right: 0 },
  columnStyles: {
    0: { cellWidth: col1Width, halign: 'left' },
    1: { cellWidth: col2Width, halign: 'center' },
  },
  headStyles: {
    fillColor: [26, 51, 160],
    textColor: 255,
    fontStyle: 'bold',
  },
});

const leftTableFinalY = doc.lastAutoTable.finalY;

// ===== RIGHT TABLE: Status Summary =====
doc.autoTable({
  head: [['Status', 'Count']],
  body: statusRows,
  startY: currentY,
  theme: 'grid',
  styles: {
    fontSize: 9,
    cellPadding: 2.8,
    halign: 'left',
    lineWidth: 0.2,
    lineColor: [0, 0, 0],
  },
  tableWidth: tableWidth,
  margin: { left: startXRight, right: 0 },
  columnStyles: {
    0: { cellWidth: col1Width, halign: 'left' },
    1: { cellWidth: col2Width, halign: 'center' },
  },
  headStyles: {
    fillColor: [26, 51, 160],
    textColor: 255,
    fontStyle: 'bold',
  },
});

const rightTableFinalY = doc.lastAutoTable.finalY;

// Move Y to the lower of the two tables
currentY = Math.max(leftTableFinalY, rightTableFinalY) + 10;


// ======= SECTION 2: CHARTS =======
let lastChartWidth = 0;
let lastChartHeight = 0;

// ---- Combined charts rendered into a single canvas to guarantee fit on one page ----
try {
  // Canvas A (complaints by type) - draw as before
  const canvasA = document.createElement('canvas');
  canvasA.width = 750; canvasA.height = 270;
  const ctxA = canvasA.getContext('2d');
  ctxA.fillStyle = '#ffffff'; ctxA.fillRect(0,0,canvasA.width, canvasA.height);
  const types = orderedTypes.filter(t => (countsByType[t] || 0) > -1);
  const maxCount = Math.max(1, ...types.map(t => countsByType[t] || 0));
  const paddingA = 20; const chartWA = canvasA.width - paddingA*2; const chartHA = canvasA.height - paddingA*2; const barWA = chartWA / Math.max(1, types.length) * 0.6;
  ctxA.strokeStyle = '#333'; ctxA.lineWidth = 1;
  ctxA.beginPath(); ctxA.moveTo(paddingA,paddingA); ctxA.lineTo(paddingA,paddingA+chartHA); ctxA.lineTo(paddingA+chartWA,paddingA+chartHA); ctxA.stroke();
  const colors = ['#1a33a0','#2a9d8f','#e76f51','#f4a261'];
  types.forEach((t,i)=>{
    const val = countsByType[t] || 0;
    const x = paddingA + (i+0.5)*(chartWA/types.length) - barWA/2;
    const h = (val / Math.max(1, maxCount)) * (chartHA - 10);
    const y = paddingA + chartHA - h;
    ctxA.fillStyle = colors[i%colors.length]; ctxA.fillRect(x,y,barWA,h);
    ctxA.fillStyle = '#000'; ctxA.font='13px Arial'; ctxA.textAlign='center'; ctxA.fillText(String(val), x+barWA/2, y-8);
    ctxA.save(); ctxA.translate(x+barWA/2, paddingA+chartHA+14); ctxA.rotate(0); ctxA.fillText(t,0,0); ctxA.restore();
  });

  // Canvas B (status summary)
  const canvasB = document.createElement('canvas');
  canvasB.width = 750; canvasB.height = 270;
  const ctxB = canvasB.getContext('2d');
  ctxB.fillStyle = '#ffffff'; ctxB.fillRect(0,0,canvasB.width, canvasB.height);
  const statuses = ['Resolved','Unresolved','Ongoing','Out of Jurisdiction','Received'];
  const statusCounts = statuses.map(s => countsByStatus[s] || 0);
  const paddingB = 20; const chartWB = canvasB.width - paddingB*2; const chartHB = canvasB.height - paddingB*2; const barWB = chartWB / Math.max(1, statuses.length) * 0.6;
  ctxB.strokeStyle = '#333'; ctxB.lineWidth = 1;
  ctxB.beginPath(); ctxB.moveTo(paddingB,paddingB); ctxB.lineTo(paddingB,paddingB+chartHB); ctxB.lineTo(paddingB+chartWB,paddingB+chartHB); ctxB.stroke();
  const scolors = ['#2a9d8f','#e9c46a','#e76f51','#9d4edd','#1a33a0'];
  statuses.forEach((st,i)=>{
    const val = statusCounts[i];
    const x = paddingB + (i+0.5)*(chartWB/statuses.length) - barWB/2;
    const h = (val / Math.max(1, Math.max(...statusCounts))) * (chartHB - 10);
    const y = paddingB + chartHB - h;
    ctxB.fillStyle = scolors[i % scolors.length]; ctxB.fillRect(x,y,barWB,h);
    ctxB.fillStyle = '#000'; ctxB.font='13px Arial'; ctxB.textAlign='center'; ctxB.fillText(String(val), x+barWB/2, y-8);
    ctxB.save(); ctxB.translate(x+barWB/2, paddingB+chartHB+14); ctxB.rotate(0); ctxB.fillText(st,0,0); ctxB.restore();
  });

  // Combine canvases side-by-side onto a single canvas
  const gap = 12;
  const combinedW = canvasA.width + gap + canvasB.width;
  const combinedH = Math.max(canvasA.height, canvasB.height);
  const combined = document.createElement('canvas');
  combined.width = combinedW; combined.height = combinedH;
  const cctx = combined.getContext('2d');
  cctx.fillStyle = '#ffffff'; cctx.fillRect(0,0,combined.width, combined.height);
  cctx.drawImage(canvasA, 0, 0);
  cctx.drawImage(canvasB, canvasA.width + gap, 0);

  // Scale combined to printable width and insert with page-break handling
  const combinedImg = combined.toDataURL('image/png');
  const imgMaxWidth = pageWidth - marginX*2;
  const imgScaledHeight = (combined.height / combined.width) * imgMaxWidth;
  const pageHeight = doc.internal.pageSize.getHeight();
  const marginBottom = 20;
  if ((currentY + imgScaledHeight) > (pageHeight - marginBottom)) {
    doc.addPage(); currentY = 28;
  }
  doc.addImage(combinedImg, 'PNG', marginX, currentY, imgMaxWidth, imgScaledHeight);
  currentY += imgScaledHeight + 10;

} catch (e) {
  console.warn('Combined chart error:', e);
}
// === End Styled Report Section ===


        // Prepare table data using your deadline functions
        const tableData = filteredComplaints.map(c => {
          let deadlineText = "N/A";
          // Use only explicit deadlines; avoid automatic fallbacks
          const explicitDeadline = explicitDeadlineForPdf(c);
          if (explicitDeadline) {
            const d = explicitDeadline;
            const dateStr = formatDateOnly(d);
            // Compute due annotation
            const msPerDay = 24*60*60*1000;
            const daysDiff = Math.ceil((d.getTime() - new Date().getTime()) / msPerDay);
            let dueAnnot = '';
            if (daysDiff < 0) {
              dueAnnot = `(Overdue by ${Math.abs(daysDiff)} day/s)`;
            } else if (daysDiff === 0) {
              dueAnnot = `(Due today)`;
            } else {
              dueAnnot = `(${daysDiff} day/s left)`;
            }
            // Date on first line, due annotation on second line
            deadlineText = `${dateStr}\n${dueAnnot}`;
          }

          // If explicit deadline exists, only annotate deadline text with (Due today)
          const now = new Date();
          const deadlineDate = explicitDeadline;
          // no additional annotation here; already included above

          const statusDisplay = computeStatusForPdf(c);

          deadlineText = sanitizeForPdf(deadlineText);

          // Date Submitted: date on first line, time on second line
          let dateSubmittedCell = "N/A";
          if (c.date_received) {
            const dr = new Date(c.date_received);
            const ds = formatDateOnly(dr);
            const ts = formatTimeOnly(dr);
            dateSubmittedCell = `${ds}\n${ts}`;
          }

          return [
            String(c.complaint_id || "N/A"),
            dateSubmittedCell,
            c.complainant_name || c.complainant || "N/A",
            c.type_of_complaint || "N/A",
            c.area_name || "N/A",
            c.assigned_to || "N/A",
            statusDisplay || "N/A",
            deadlineText,
            c.latest_action || c.action_needed || "N/A",
            c.priority_level || "Minor"
          ];
        });

        // Start detailed complaint table after the summary/stats/chart/overdue sections
        let startY = currentY || 28;
        // Generate PDF Table
        doc.autoTable({
          head: [[
            "ID",
            "Date Submitted",
            "Complainant",
            "Type of Complaint",
            "HOA",
            "Assigned To",
            "Status",
            "Deadline",
            "Action Needed",
            "Priority Level"
          ]],
          body: tableData,
          startY,
          theme: "grid",
          headStyles: {
            fillColor: [26, 51, 160],
            textColor: [255, 255, 255],
            fontStyle: "bold",
            lineWidth: 0.3
          },
          styles: {
            fontSize: 9,
            lineWidth: 0.2,
            lineColor: [0, 0, 0],
            textColor: [0, 0, 0]
          },
        });

        // Save PDF
        doc.save(`Complaints_Report_${monthYear}.pdf`);
      } catch (error) {
        console.error("Error generating report:", error);
        alert("Failed to generate report. Please try again.");
      }
    }

    // ✅ Button logic
    document.addEventListener("DOMContentLoaded", () => {
      loadAllComplaints();
      loadStats();

      const monthPicker = document.getElementById("reportMonthPicker");
      const generateBtn = document.getElementById("generateReportBtn");

      let pickerVisible = false;

      generateBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        if (!pickerVisible) {
          monthPicker.style.display = "inline-block";
          monthPicker.focus();
          pickerVisible = true;
        } else {
          monthPicker.style.display = "none";
          pickerVisible = false;
        }
      });

      monthPicker.addEventListener("change", async () => {
        pickerVisible = false;
        monthPicker.style.display = "none";
        await generateReport();
      });

      document.addEventListener("click", (e) => {
        if (!monthPicker.contains(e.target) && !generateBtn.contains(e.target)) {
          monthPicker.style.display = "none";
          pickerVisible = false;
        }
      });
    });
  </script>

 <script>
    document.addEventListener("DOMContentLoaded", () => {
      const toggle = document.getElementById("dateDropdownToggle");
      const menu = document.getElementById("dateDropdownMenu");
      let calendarVisible = false;

      if (!menu) return;

      // Create dropdown content if it doesn't exist
      if (!menu.innerHTML.trim()) {
        menu.innerHTML = `
          <div id="dropdownContent" style="
            display: flex; 
            flex-direction: column; 
            padding: 8px; 
            background: white; 
            border: 1px solid #ccc; 
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            min-width: 220px;
          ">
            <input type="date" id="dateFilterInput" style="
              padding: 6px; 
              font-size: 14px; 
              border: 1px solid #1a33a0; 
              border-radius: 4px; 
              margin-bottom: 8px;
              outline: none;
            ">
            <button id="showAllBtn" style="
              background: #1a33a0; 
              color: white; 
              border: none; 
              border-radius: 4px; 
              padding: 6px;
              cursor: pointer;
            ">Show All</button>
          </div>
        `;
      }

      const dateInput = menu.querySelector("#dateFilterInput");
      const showAllBtn = menu.querySelector("#showAllBtn");

      // Toggle dropdown visibility
      toggle.addEventListener("click", (e) => {
        e.stopPropagation();
        calendarVisible = !calendarVisible;
        menu.style.display = calendarVisible ? "block" : "none";
        menu.style.position = "absolute";

        // Add a little margin (e.g., 6-8px) below the toggle
        const verticalOffset = toggle.offsetHeight + 6; // 6px margin
        menu.style.top = verticalOffset + "px";
        menu.style.zIndex = "9999";
      });


      // Close dropdown if clicking outside
      document.addEventListener("click", (e) => {
        if (!menu.contains(e.target) && !toggle.contains(e.target)) {
          menu.style.display = "none";
          calendarVisible = false;
        }
      });

      function filterTableByDate(selectedDate) {
        const rows = document.querySelectorAll("#complaints-table-body tr");
        let visibleCount = 0;

        rows.forEach(row => {
          const dateCell = row.querySelector("td:nth-child(1)");
          if (!dateCell) return;

          // Use local date instead of UTC
          const cellDateObj = new Date(dateCell.textContent.trim());
          const cellDate = cellDateObj.getFullYear() + '-' +
                          String(cellDateObj.getMonth() + 1).padStart(2, '0') + '-' +
                          String(cellDateObj.getDate()).padStart(2, '0');

          if (!selectedDate || cellDate === selectedDate) {
            row.style.display = "";
            visibleCount++;
          } else {
            row.style.display = "none";
          }
        });

        // Remove existing "No complaints" message
        const emptyMsg = document.getElementById("noComplaintsMsg");
        if (emptyMsg) emptyMsg.remove();

        // Add message only if no rows are visible
        if (visibleCount === 0) {
          const msgRow = document.createElement("tr");
          msgRow.id = "noComplaintsMsg";
          msgRow.innerHTML = `<td colspan="9" style="text-align:center; color:#888; padding:8px;">No complaints found for this date.</td>`;
          document.querySelector("#complaints-table-body").appendChild(msgRow);
        }
      }

      dateInput.addEventListener("change", () => {
        filterTableByDate(dateInput.value);
      });

      showAllBtn.addEventListener("click", () => {
        dateInput.value = "";

        // Remove any existing "No complaints" message immediately
        const emptyMsg = document.getElementById("noComplaintsMsg");
        if (emptyMsg) emptyMsg.remove();

        // Show all rows
        const rows = document.querySelectorAll("#complaints-table-body tr");
        rows.forEach(row => {
          row.style.display = "";
        });

        // Hide the dropdown
        menu.style.display = "none";
        calendarVisible = false;
      });
    });
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const inboxBtn = document.getElementById("inboxBtn");
      const inboxMenu = document.getElementById("inboxMenu");
      const inboxList = document.getElementById("inboxList");
      const notifCount = document.getElementById("notifCount");

      // Toggle dropdown
      inboxBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        inboxMenu.style.display = inboxMenu.style.display === "block" ? "none" : "block";
      });

      document.addEventListener("click", (e) => {
        if (!inboxMenu.contains(e.target) && !inboxBtn.contains(e.target)) {
          inboxMenu.style.display = "none";
        }
      });

      try {
        // Use EXACT same logic as index.html - fetch from multiple endpoints and use the same helper functions
        const urls = [
          `/admin/complaints/api/assigned?_=${Date.now()}`,
          `/admin/complaints/api/ongoing?_=${Date.now()}`,
          `/admin/complaints/api/all?_=${Date.now()}`
        ];
        let adminAssignedCache = [];
        let loaded = false;

        // Try each endpoint until we get data
        for (const url of urls) {
          try {
            const res = await fetch(url);
            if (!res.ok) continue;
            const data = await res.json();
            const list = Array.isArray(data) 
              ? data 
              : (data.success && data.complaints) 
                ? data.complaints 
                : [];

            if (list.length) {
              adminAssignedCache = list;
              loaded = true;
              break;
            }
          } catch (_) { /* try next */ }
        }

        // Fallback: also try staff view if admin endpoints empty
        if (!loaded) {
          try {
            const res = await fetch(`/staff/api/complaints/assigned?_=${Date.now()}`);
            if (res.ok) {
              const data = await res.json();
              adminAssignedCache = Array.isArray(data.complaints) ? data.complaints : [];
            }
          } catch (_) {
            adminAssignedCache = [];
          }
        }

        // Use EXACT same helper functions as index.html
        function normalizeComplaint(raw) {
          return {
            complaint_id: raw.complaint_id || raw.id || raw.complaintId,
            complaint_stage: raw.complaint_stage || raw.stage || raw.status || '',
            status: raw.status || '',
            latest_action: raw.latest_action || raw.action_type || raw.action || raw.action_needed || '',
            action_datetime: raw.action_datetime || raw.last_action_datetime || raw.updated_at || raw.actionDateTime || '',
            date_received: raw.date_received || raw.submitted_at || raw.created_at || raw.createdAt || '',
            complainant: raw.complainant_name || raw.complainant || raw.fullname || '',
            complainant_name: raw.complainant_name || raw.complainant || raw.fullname || '',
            area_name: raw.area_name || raw.area || raw.areaName || '',
            type_of_complaint: raw.type_of_complaint || raw.complaint_type || raw.complaintType || '',
            deadline: raw.deadline || raw.action_deadline || raw.deadline_at || raw.due_date || raw.due_at || ''
          };
        }

        function adminGetDeadlineDate(complaint) {
          if (!complaint) return null;

          // Only show deadlines for Pending or Ongoing complaints
          if (complaint.complaint_stage === 'Resolved') return null;
          if ((complaint.status || '').toLowerCase().includes('invalid')) return null;
          if ((complaint.status || '').toLowerCase().includes('resolved')) return null;

          // Filter to only Pending or Ongoing complaints
          if (complaint.complaint_stage !== 'Pending' && complaint.complaint_stage !== 'Ongoing') return null;

          // For Pending complaints
          if (complaint.complaint_stage === 'Pending' || !complaint.latest_action) {
            const submittedDate = new Date(complaint.date_received);
            if (isNaN(submittedDate.getTime())) return null;
            // 6 days after submission (same as Deadline column logic)
            return new Date(submittedDate.getTime() + 6 * 24 * 60 * 60 * 1000);
          }

          // For Ongoing complaints - use same logic as Deadline column
          if (!complaint.action_datetime) return null;
          const actionDate = new Date(complaint.action_datetime);
          if (isNaN(actionDate.getTime())) return null;

          const actionType = (complaint.latest_action || '').toLowerCase();

          // Get admin-set deadline for inspection
          let adminDeadline = null;
          if (complaint.deadline) {
            console.log(`[ALL INBOX] Complaint ${complaint.complaint_id}: Using deadline field = "${complaint.deadline}"`);
            adminDeadline = new Date(complaint.deadline);
          } else {
            console.log(`[ALL INBOX] Complaint ${complaint.complaint_id}: No deadline field found, using fallback`);
          }

          // Get meeting datetime from invitation action
          let meetingDateTime = null;
          if (complaint.meeting_datetime) {
            meetingDateTime = new Date(complaint.meeting_datetime);
          } else if (complaint.meeting_date && complaint.meeting_time) {
            meetingDateTime = new Date(`${complaint.meeting_date}T${complaint.meeting_time}`);
          }

          // Calculate deadline based on action type (same as Deadline column)
          if (actionType.includes('inspection') && !actionType.includes('done')) {
            return adminDeadline || new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('inspection done')) {
            return new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('send invitation') || (actionType.includes('invitation') && !actionType.includes('sent') && !actionType.includes('accepted'))) {
            return new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('sent invitation')) {
            return new Date(actionDate.getTime() + (20 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('accepted invitation')) {
            return meetingDateTime || actionDate;
          } else if (actionType.includes('mediation')) {
            const baseDate = meetingDateTime || actionDate;
            return new Date(baseDate.getTime() + (3 * 24 * 60 * 60 * 1000));
          } else if (actionType.includes('assessment')) {
            return null; // Assessment has no deadline
          } else {
            return new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
          }
        }

        function adminGetDaysLeft(deadline) {
          if (!deadline) return null;
          const now = new Date();
          
          // Normalize dates to compare only the date part (ignore time) - consistent with assigned.html and all.html
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
          const deadlineDate = new Date(deadline.getFullYear(), deadline.getMonth(), deadline.getDate(), 0, 0, 0, 0);
          
          const timeDiff = deadlineDate.getTime() - today.getTime();
          return Math.round(timeDiff / (1000 * 60 * 60 * 24));
        }

        function adminBuildDueSoonItems(complaints) {
          const items = [];
          complaints.forEach(raw => {
            const c = normalizeComplaint(raw);
            const deadline = adminGetDeadlineDate(c);
            if (!deadline) return;

            const daysLeft = adminGetDaysLeft(deadline);
            if (daysLeft === null) return;

            // Include if overdue (daysLeft < 0) or due soon (<=3 days)
            if (daysLeft <= 3) {
              const isPending = (c.complaint_stage === 'Pending') || !c.latest_action;
              items.push({ complaint: c, deadline, daysLeft, isPending });
            }
          });

          // Sort: overdue first, then soonest due
          items.sort((a, b) => a.daysLeft - b.daysLeft);
          return items;
        }

        // Build due soon items using exact same logic as index.html
        const dueSoonItems = adminBuildDueSoonItems(adminAssignedCache);

        const totalCount = dueSoonItems.length;
        notifCount.textContent = totalCount > 0 ? totalCount : "0";
        notifCount.style.display = totalCount > 0 ? "inline-block" : "none";

        inboxList.innerHTML = "";
        if (totalCount === 0) {
          inboxList.innerHTML = `<p style="margin: 0; font-size: 14px; color: #666;">No tasks due soon.</p>`;
          return;
        }

        const formatDateTime = (date) => {
          const options = {
            month: "short", day: "numeric", year: "numeric",
            hour: "2-digit", minute: "2-digit",
          };
          return date.toLocaleString("en-US", options);
        };

        const buildEntry = (color, label, dueDate, c) => `
          <div style="padding: 10px; border-bottom: 2px solid #ccc;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <strong style="color:${color}; font-size:14px;">${label}</strong>
            </div>
            <small style="display:block; color:#999;">Due: ${formatDateTime(dueDate)}</small>
            <div style="font-size: 13px; margin-top: 6px;">
              ${c.type_of_complaint} - <small style="color:#555;">${c.complainant_name || c.complainant || "N/A"}</small>
            </div>
          </div>
        `;

        // Render all due soon items with consistent labeling logic
        dueSoonItems.forEach(c => {
          let color, label;
          if (c.daysLeft < 0) {
            const daysLate = Math.abs(c.daysLeft);
            color = "red";
            label = `Overdue (${daysLate} day${daysLate !== 1 ? "s" : ""} late)`;
          } else if (c.daysLeft === 0) {
            color = "orange";
            label = "Due Today";
          } else {
            color = "green";
            label = `Ongoing (${c.daysLeft} day${c.daysLeft !== 1 ? "s" : ""} left)`;
          }

          inboxList.innerHTML += buildEntry(color, label, c.deadline, c.complaint);
        });

      } catch (err) {
        console.error("Error loading inbox:", err);
        inboxList.innerHTML = `<p style="color:red;">Failed to load inbox.</p>`;
      }
    });
  </script>

  <script>
    // Sorting functionality for Type of Complaint, Assigned To, and Priority Level
    document.addEventListener("DOMContentLoaded", () => {
      // Type of Complaint sorting
      const typeToggle = document.getElementById("typeDropdownToggle");
      const typeMenu = document.getElementById("typeDropdownMenu");
      let typeMenuVisible = false;

      if (typeToggle && typeMenu) {
        // Create dropdown content for Type of Complaint
        typeMenu.innerHTML = `
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="all">Show All</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Overlapping">Overlapping</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Pathway Dispute">Pathway Dispute</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Lot Dispute">Lot Dispute</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Boundary Dispute">Boundary Dispute</div>
          <div style="padding: 8px 12px; cursor: pointer;" data-sort="Unauthorized Occupation">Unauthorized Occupation</div>
        `;

        typeToggle.addEventListener("click", (e) => {
          e.stopPropagation();
          typeMenuVisible = !typeMenuVisible;
          typeMenu.style.display = typeMenuVisible ? "block" : "none";
          // Close other dropdowns
          if (typeMenuVisible) {
            document.getElementById("assignedDropdownMenu").style.display = "none";
            document.getElementById("priorityDropdownMenu").style.display = "none";
          }
        });

        // Handle type filter selection
        typeMenu.addEventListener("click", (e) => {
          const sortValue = e.target.getAttribute("data-sort");
          if (sortValue) {
            filterByType(sortValue);
            typeMenu.style.display = "none";
            typeMenuVisible = false;
          }
        });
      }

      // Assigned To sorting
      const assignedToggle = document.getElementById("assignedDropdownToggle");
      const assignedMenu = document.getElementById("assignedDropdownMenu");
      let assignedMenuVisible = false;

      if (assignedToggle && assignedMenu) {
        // Create dropdown content for Assigned To
        assignedMenu.innerHTML = `
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="all">Show All</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Josie Rosal">Josie Rosal</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Alberto Nonato Jr.">Alberto Nonato Jr.</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Maybelen Jamorawon">Maybelen Jamorawon</div>
          <div style="padding: 8px 12px; cursor: pointer;" data-sort="Agnes Bartolome">Agnes Bartolome</div>
        `;

        assignedToggle.addEventListener("click", (e) => {
          e.stopPropagation();
          assignedMenuVisible = !assignedMenuVisible;
          assignedMenu.style.display = assignedMenuVisible ? "block" : "none";
          // Close other dropdowns
          if (assignedMenuVisible) {
            document.getElementById("typeDropdownMenu").style.display = "none";
            document.getElementById("priorityDropdownMenu").style.display = "none";
          }
        });

        // Handle assigned filter selection
        assignedMenu.addEventListener("click", (e) => {
          const sortValue = e.target.getAttribute("data-sort");
          if (sortValue) {
            filterByAssigned(sortValue);
            assignedMenu.style.display = "none";
            assignedMenuVisible = false;
          }
        });
      }

      // Priority Level sorting
      const priorityToggle = document.getElementById("priorityDropdownToggle");
      const priorityMenu = document.getElementById("priorityDropdownMenu");
      let priorityMenuVisible = false;

      if (priorityToggle && priorityMenu) {
        // Create dropdown content for Priority Level
        priorityMenu.innerHTML = `
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="all">Show All</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Severe">1. Severe</div>
          <div style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;" data-sort="Moderate">2. Moderate</div>
          <div style="padding: 8px 12px; cursor: pointer;" data-sort="Minor">3. Minor</div>
        `;

        priorityToggle.addEventListener("click", (e) => {
          e.stopPropagation();
          priorityMenuVisible = !priorityMenuVisible;
          priorityMenu.style.display = priorityMenuVisible ? "block" : "none";
          // Close other dropdowns
          if (priorityMenuVisible) {
            document.getElementById("typeDropdownMenu").style.display = "none";
            document.getElementById("assignedDropdownMenu").style.display = "none";
          }
        });

        // Handle priority filter selection
        priorityMenu.addEventListener("click", (e) => {
          const sortValue = e.target.getAttribute("data-sort");
          if (sortValue) {
            filterByPriority(sortValue);
            priorityMenu.style.display = "none";
            priorityMenuVisible = false;
          }
        });
      }

      // Close dropdowns when clicking outside
      document.addEventListener("click", (e) => {
        if (typeMenu) typeMenu.style.display = "none";
        if (assignedMenu) assignedMenu.style.display = "none";
        if (priorityMenu) priorityMenu.style.display = "none";
        typeMenuVisible = false;
        assignedMenuVisible = false;
        priorityMenuVisible = false;
      });
    });

    // Format date with timestamp (date on top, time on bottom)
    function formatDateWithTimestamp(dateString) {
      if (!dateString) return 'N/A';
      
      try {
        const date = new Date(dateString);
        const dateStr = date.toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', year: 'numeric'
        });
        const timeStr = date.toLocaleTimeString('en-US', {
          hour: '2-digit', minute: '2-digit', hour12: true
        });
        return `${dateStr}<br/>${timeStr}`;
      } catch (error) {
        console.error('Error formatting date:', error);
        return dateString;
      }
    }

    // Filter functions
    function filterByType(type) {
      let filteredData = type === 'all' ? allComplaintsData : 
        allComplaintsData.filter(complaint => complaint.type_of_complaint === type);
      populateTable(filteredData);
    }

    function filterByAssigned(assigned) {
      let filteredData = assigned === 'all' ? allComplaintsData : 
        allComplaintsData.filter(complaint => complaint.assigned_to === assigned);
      populateTable(filteredData);
    }

    function filterByPriority(priority) {
      if (priority === 'all') {
        populateTable(allComplaintsData);
      } else {
        // Sort by priority order: Severe -> Moderate -> Minor
        let filteredData = allComplaintsData.filter(complaint => 
          (complaint.priority_level || 'Minor') === priority);
        populateTable(filteredData);
      }
    }
  </script>

<style>
  .inbox-dropdown button:hover i {
  color: #14257a;
  transform: scale(1.05);
  transition: all 0.2s ease;
}

#inboxMenu div:hover {
  background-color: #f8f9fa;
}

</style>

</body>
</html>
