<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/admin.css">
  <style>
    .priority-severe { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .priority-moderate { background-color: #ffc107; color: black; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .priority-minor { background-color: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    /* Uniform table row styling with consistent row heights */
    .complaints-table tbody tr { 
      min-height: 70px; 
      height: 70px;
    }
    .complaints-table tbody td { 
      padding: 12px 8px; 
      vertical-align: middle; 
      word-wrap: break-word; 
      line-height: 1.4;
      max-height: 70px;
      overflow: hidden;
    }
    /* Center align all table contents and adjust column widths */
    .complaints-table th, .complaints-table td { text-align: center; }
    .complaints-table th:nth-child(2), .complaints-table td:nth-child(2) { min-width: 150px; width: 150px; } /* Complainant */
    .complaints-table th:nth-child(4), .complaints-table td:nth-child(4) { min-width: 150px; width: 150px; } /* HOA - increased width */
    .complaints-table th:nth-child(5), .complaints-table td:nth-child(5) { min-width: 140px; width: 140px; } /* Assigned To */
    .complaints-table th:nth-child(7), .complaints-table td:nth-child(7) { min-width: 130px; width: 130px; } /* Action Needed - reduced width */
    /* Status-based row colors - higher specificity */
    .complaints-table tbody tr.status-inspection { background-color: #A7D8F2 !important; cursor: pointer; }
    .complaints-table tbody tr.status-inspection:hover { background-color: #85C7ED !important; }
    .complaints-table tbody tr.status-invitation { background-color: #a6a5ff !important; cursor: pointer; }
    .complaints-table tbody tr.status-invitation:hover { background-color: #8D8CFF !important; }
    .complaints-table tbody tr.status-mediation { background-color: #C9B6E4 !important; cursor: pointer; }
    .complaints-table tbody tr.status-mediation:hover { background-color: #B8A1D9 !important; }
    .complaints-table tbody tr.status-assessment { background-color: #B5E48C !important; cursor: pointer; }
    .complaints-table tbody tr.status-assessment:hover { background-color: #A0DB70 !important; }
    .complaints-table tbody tr:hover { cursor: pointer; }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/admin/dashboard" class="nav-item">Map</a>
      <a href="/admin/complaints/all.html" class="nav-item active">Complaints</a>
      <a href="/admin/database/beneficiaries.html" class="nav-item">Beneficiaries</a>
      <a href="/admin/database/policies.html" class="nav-item">Policies</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <div class="main-content">
    <h1>Complaints</h1>
    
    <!-- Stats -->
    <div class="stats">
      <div class="stat-card">
        <i class="bi bi-graph-up-arrow"></i>
        <div>
          <h2>0</h2>
          <p>Complaints</p>
        </div>
      </div>
      
      <div class="stat-card">
        <i class="bi bi-person-exclamation"></i>
        <div>
          <h2>0</h2>
          <p>On Going</p>   
        </div>
      </div>
      
      <div class="stat-card">
        <i class="bi bi-person-x"></i>
        <div>
         <h2>0</h2>
          <p>Unresolved</p>
        </div>
      </div>
    </div>
        
    <!-- Tabs -->
    <div class="tabs">
      <a href="all.html"> All</a>
      <a href="pending.html">Received</a>
      <a href="ongoing.html" class="active">On Going</a>
      <a href="resolved.html">Resolved</a>
      <a href="invalid.html">Out of Jurisdiction</a>
      <a href="unresolved.html">Unresolved</a>
    </div>

    <!-- Table -->
    <div class="table-container">
    <table class="complaints-table">
      <thead>
        <tr>
          <th style="text-align: center;">ID No.</th> <!-- Future format: MMDDYY-ID (e.g., 100825-123) -->
          <th style="text-align: center;">Date Submitted</th>
          <th style="text-align: center;">Complainant</th>
          <th style="text-align: center;">Type of Complaint</th>
          <th style="text-align: center;">HOA</th>
          <th style="text-align: center;">Assigned To</th>
          <th style="text-align: center;">Deadline</th>
          <th style="text-align: center;">Stage of Action</th>
          <th style="text-align: center;">Priority Level</th>
        </tr>
      </thead>
        
      <tbody id="complaints-table-body">
        <!-- Dynamic data will be loaded here -->
      </tbody>
    </table>
    </div>
  </div>


  <script>
    // Helper: safe JSON parse for details field
    function parseDetailsSafe(details) {
      if (!details) return null;
      if (typeof details === 'object') return details;
      try { return JSON.parse(details); } catch { return null; }
    }

    // Recursively find meeting datetime in an arbitrary details object
    function findMeetingDateTime(details) {
      if (!details || typeof details !== 'object') return null;
      // Direct keys first
      if (details.meeting_datetime) {
        const d = new Date(details.meeting_datetime);
        if (!isNaN(d.getTime())) return d;
      }
      if (details.meeting_date && details.meeting_time) {
        const d = new Date(`${details.meeting_date}T${details.meeting_time}`);
        if (!isNaN(d.getTime())) return d;
      }
      // Common alternates (defensive)
      const altDate = details.meetingDate || details.date_of_meeting || details.mediation_date;
      const altTime = details.meetingTime || details.time_of_meeting || details.mediation_time;
      if (altDate && altTime) {
        const d = new Date(`${altDate}T${altTime}`);
        if (!isNaN(d.getTime())) return d;
      }
      const altDT = details.meetingDateTime || details.mediation_datetime || details.schedule_datetime;
      if (altDT) {
        const d = new Date(altDT);
        if (!isNaN(d.getTime())) return d;
      }
      // Recurse through nested objects/arrays
      for (const key of Object.keys(details)) {
        const v = details[key];
        if (v && typeof v === 'object') {
          const nested = findMeetingDateTime(v);
          if (nested) return nested;
        }
      }
      return null;
    }

    // Async fallback: If Accepted Invitation lacks meeting data on the row payload,
    // fetch timeline and derive meeting date/time from the Invitation action.
    async function resolveAcceptedInvitationDeadline(complaintId, deadlineCell) {
      try {
        if (!complaintId || !deadlineCell) return;
        console.log(`[ONGOING] ü§ù Fallback resolver for complaint ${complaintId} - fetching timeline`);
        const res = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=admin&_=${Date.now()}`);
        if (!res.ok) throw new Error(`Timeline fetch failed: ${res.status}`);
        const data = await res.json();
        const timeline = Array.isArray(data) ? data : (Array.isArray(data.entries) ? data.entries : (data.timeline || []));
        console.log(`[ONGOING] ü§ù Timeline entries for ${complaintId}:`, Array.isArray(timeline) ? timeline.length : 'N/A');
        if (!Array.isArray(timeline) || timeline.length === 0) {
          console.warn(`[ONGOING] ü§ù No timeline found for complaint ${complaintId}`);
          return;
        }
        // Search from latest to oldest for an Invitation entry with meeting info
        let found = null;
        for (let i = timeline.length - 1; i >= 0; i--) {
          const t = timeline[i];
          const actionTxt = ((t.action || t.status || '') + '').toLowerCase();
          const detailsObj = parseDetailsSafe(t.details) || t.details || null;
          // Prefer invitation-like actions, but also accept any entry whose details contain meeting info
          if (!actionTxt.includes('invitation') && !actionTxt.includes('mediation')) {
            // still check details in case structure differs
            const anyDT = findMeetingDateTime(detailsObj);
            if (anyDT && !isNaN(anyDT.getTime())) { found = anyDT; break; }
            continue;
          }
          const meetingDT = findMeetingDateTime(detailsObj);
          if (meetingDT && !isNaN(meetingDT.getTime())) { found = meetingDT; break; }
        }
        if (found) {
          const dateStr = found.toLocaleDateString();
          const timeStr = found.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          deadlineCell.innerHTML = `${dateStr} | ${timeStr}<br/>(Mediation day)`;
          console.log(`[ONGOING] ü§ù Fallback applied for ${complaintId}: ${dateStr} ${timeStr}`);
        } else {
          console.warn(`[ONGOING] ü§ù No invitation with meeting info found in timeline for ${complaintId}`);
        }
      } catch (e) {
        console.warn(`[ONGOING] ü§ù Fallback resolver error for complaint ${complaintId}:`, e);
      }
    }

    // Format date with timestamp for display
    function formatDateWithTimestamp(dateString) {
      try {
        if (!dateString) return 'N/A';
        
        const date = new Date(dateString);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        const dateStr = date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        const timeStr = date.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });
        
        return `${dateStr}<br><small style="color: #666;">${timeStr}</small>`;
      } catch (error) {
        console.error('Date formatting error:', error);
        return dateString || 'N/A';
      }
    }

    // Load ongoing complaints data
    async function loadOngoingComplaints() {
      try {
        console.log('Loading ongoing complaints...');
        const response = await fetch(`/admin/complaints/api/ongoing?_=${Date.now()}`);
        console.log('API response status:', response.status);
        
        const data = await response.json();
        console.log('API response data:', data);
        console.log('Data type:', typeof data, 'Is array:', Array.isArray(data));
        
        if (Array.isArray(data)) {
          console.log('Processing array of', data.length, 'complaints');
          populateTable(data);
        } else if (data.success && data.complaints) {
          console.log('Processing success response with', data.complaints.length, 'complaints');
          populateTable(data.complaints);
        } else {
          console.error('Failed to load complaints:', data.message || 'Unknown error');
          console.error('Full response data:', data);
        }
      } catch (error) {
        console.error('Error loading complaints:', error);
      }
    }

    // Load admin statistics
    async function loadStats() {
      try {
        const [statsResponse, unresolvedResponse] = await Promise.all([
          fetch(`/admin/complaints/api/stats?_=${Date.now()}`),
          fetch(`/admin/complaints/api/unresolved?_=${Date.now()}`)
        ]);
        
        const statsData = await statsResponse.json();
        const unresolvedData = await unresolvedResponse.json();
        
        if (statsData.total !== undefined) {
          document.querySelector('.stat-card:nth-child(1) h2').textContent = statsData.total || 0;
          document.querySelector('.stat-card:nth-child(2) h2').textContent = statsData.ongoing || 0;
        }
        
        // Count unresolved from dedicated endpoint
        const unresolvedCount = Array.isArray(unresolvedData) ? unresolvedData.length : 
                               (unresolvedData.complaints ? unresolvedData.complaints.length : 0);
        document.querySelector('.stat-card:nth-child(3) h2').textContent = unresolvedCount;
        
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    }

    // Populate the table with complaint data
    function populateTable(complaints) {
      console.log('populateTable called with:', complaints);
      const tbody = document.getElementById('complaints-table-body');
      tbody.innerHTML = '';
      
      if (!complaints || complaints.length === 0) {
        console.log('No complaints to display');
        tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">No ongoing complaints</td></tr>';
        return;
      }
      
      console.log('Processing', complaints.length, 'complaints');
      complaints.forEach((complaint, index) => {
        try {
          console.log(`Processing complaint ${index + 1}:`, complaint);
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        
        row.addEventListener('click', () => {
          const detailsPage = complaint.status === 'Invalid' ? 'complaint_details_invalid.html' : 'complaint_details_valid.html';
          window.location.href = `/admin/complaints/${detailsPage}?id=${complaint.complaint_id}&referrer=ongoing.html`;
        });
        
        // Enhanced deadline calculation based on admin-set deadlines and meeting times
        const formatDeadline = (complaint) => {
          if (!complaint.action_datetime) return 'N/A';
          
          const actionType = (complaint.latest_action || complaint.action_needed || '').toLowerCase();
          const actionDate = new Date(complaint.action_datetime);
          
          console.log(`[ONGOING] üîç DEBUGGING Complaint ${complaint.complaint_id}`);
          console.log(`[ONGOING] üîç Raw actionType: "${complaint.latest_action || complaint.action_needed}"`);
          console.log(`[ONGOING] üîç Lowercase actionType: "${actionType}"`);
          console.log(`[ONGOING] üîç Action date: ${actionDate}`);
          console.log(`[ONGOING] üîç Complaint object:`, complaint);
          
          // Get admin-set deadline for inspection from complaint history/actions - use the deadline from API
          let adminDeadline = null;
          if (complaint.deadline) {
            adminDeadline = new Date(complaint.deadline);
          }
          
          // Get meeting datetime from invitation action in complaint history
          let meetingDateTime = null;
          console.log(`[ONGOING] üìÖ Meeting data check for complaint ${complaint.complaint_id}:`);
          console.log(`[ONGOING] üìÖ   - meeting_date: "${complaint.meeting_date}"`);
          console.log(`[ONGOING] üìÖ   - meeting_time: "${complaint.meeting_time}"`);
          console.log(`[ONGOING] üìÖ   - meeting_datetime: "${complaint.meeting_datetime}"`);
          console.log(`[ONGOING] üìÖ   - Full complaint object keys:`, Object.keys(complaint));
          console.log(`[ONGOING] üìÖ   - Details field:`, complaint.details);
          console.log(`[ONGOING] üìÖ   - complaint_history field:`, complaint.complaint_history);
          
          if (complaint.meeting_datetime && complaint.meeting_datetime !== 'null' && complaint.meeting_datetime !== null) {
            meetingDateTime = new Date(complaint.meeting_datetime);
            console.log(`[ONGOING] üìÖ   - Using meeting_datetime: ${meetingDateTime}`);
          } else if (complaint.meeting_date && complaint.meeting_time && 
                     complaint.meeting_date !== 'null' && complaint.meeting_date !== null &&
                     complaint.meeting_time !== 'null' && complaint.meeting_time !== null) {
            meetingDateTime = new Date(`${complaint.meeting_date}T${complaint.meeting_time}`);
            console.log(`[ONGOING] üìÖ   - constructed meetingDateTime: ${meetingDateTime}`);
            console.log(`[ONGOING] üìÖ   - meetingDateTime valid: ${!isNaN(meetingDateTime.getTime())}`);
          } else {
            console.log(`[ONGOING] üìÖ   - No meeting data available in top-level fields`);
            
            // Check if there are nested details that might contain meeting info
            if (complaint.details) {
              console.log(`[ONGOING] üìÖ   - Found details field:`, complaint.details);
              try {
                const detailsObj = typeof complaint.details === 'string' ? JSON.parse(complaint.details) : complaint.details;
                if (detailsObj.meeting_date && detailsObj.meeting_time) {
                  meetingDateTime = new Date(`${detailsObj.meeting_date}T${detailsObj.meeting_time}`);
                  console.log(`[ONGOING] üìÖ   - Found meeting data in details: ${meetingDateTime}`);
                }
              } catch (e) {
                console.log(`[ONGOING] üìÖ   - Error parsing details:`, e);
              }
            }
          }
          
          if (actionType.includes('inspection') && !actionType.includes('done')) {
            // Inspection ‚Üí Use admin-set deadline
            console.log(`[ONGOING] Complaint ${complaint.complaint_id}: deadline field = "${complaint.deadline}", adminDeadline = ${adminDeadline}`);
            if (adminDeadline) {
              const dateStr = adminDeadline.toLocaleDateString();
              const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              console.log(`[ONGOING] Using admin deadline: ${dateStr}`);
              return `${dateStr}<br/>${timeStr}`;
            }
            // Fallback to 3 days if no admin deadline set
            console.log(`[ONGOING] No admin deadline, using 3-day fallback`);
            const deadline = new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
            const dateStr = deadline.toLocaleDateString();
            const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            return `${dateStr}<br/>${timeStr}`;
          }
          
          else if (actionType.includes('accepted invitation')) {
            // Accepted Invitation ‚Üí Use meeting_date from Invitation details as the deadline
            console.log(`[ONGOING] ü§ù ACCEPTED INVITATION - Complaint ${complaint.complaint_id}`);
            console.log(`[ONGOING] ü§ù   - meetingDateTime: ${meetingDateTime}`);
            console.log(`[ONGOING] ü§ù   - actionDate: ${actionDate}`);
            
            // If no meetingDateTime yet, try to derive it from the original Invitation action in history
            try {
              if ((!meetingDateTime || isNaN(meetingDateTime.getTime())) && (complaint.details || complaint.complaint_history)) {
                let originalInvitationId = null;
                try {
                  const acceptedDetailsObj = typeof complaint.details === 'string' ? JSON.parse(complaint.details) : complaint.details;
                  if (acceptedDetailsObj && acceptedDetailsObj.original_invitation_id) {
                    originalInvitationId = String(acceptedDetailsObj.original_invitation_id);
                  }
                } catch (e) {
                  console.warn(`[ONGOING] ü§ù   - Failed to parse Accepted Invitation details for original_invitation_id`, e);
                }

                const history = Array.isArray(complaint.complaint_history) ? complaint.complaint_history : [];
                let foundDetails = null;

                // First pass: exact match by id or details.invitation_id/original_invitation_id
                for (const h of history) {
                  if (foundDetails) break;
                  const action = ((h.action || h.status || '') + '').toLowerCase();
                  // Only consider invitation-type actions
                  if (!action.includes('invitation')) continue;
                  let detailsObj = null;
                  try {
                    detailsObj = typeof h.details === 'string' ? JSON.parse(h.details) : h.details;
                  } catch (_) {}
                  const hid = (h.id != null ? String(h.id) : (h.action_id != null ? String(h.action_id) : null));
                  const invitationIdInDetails = detailsObj && (detailsObj.invitation_id || detailsObj.original_invitation_id) ? String(detailsObj.invitation_id || detailsObj.original_invitation_id) : null;
                  const hasMeeting = detailsObj && ((detailsObj.meeting_datetime) || (detailsObj.meeting_date && detailsObj.meeting_time));
                  if (!hasMeeting) continue;
                  if (originalInvitationId && (hid === originalInvitationId || invitationIdInDetails === originalInvitationId)) {
                    foundDetails = detailsObj;
                    break;
                  }
                }

                // Second pass: fallback to latest invitation with meeting info
                if (!foundDetails) {
                  for (let i = history.length - 1; i >= 0; i--) {
                    const h = history[i];
                    const action = ((h.action || h.status || '') + '').toLowerCase();
                    if (!action.includes('invitation')) continue;
                    let detailsObj = null;
                    try {
                      detailsObj = typeof h.details === 'string' ? JSON.parse(h.details) : h.details;
                    } catch (_) {}
                    if (detailsObj && (detailsObj.meeting_datetime || (detailsObj.meeting_date && detailsObj.meeting_time))) {
                      foundDetails = detailsObj;
                      break;
                    }
                  }
                }

                if (foundDetails) {
                  if (foundDetails.meeting_datetime) {
                    meetingDateTime = new Date(foundDetails.meeting_datetime);
                  } else if (foundDetails.meeting_date && foundDetails.meeting_time) {
                    meetingDateTime = new Date(`${foundDetails.meeting_date}T${foundDetails.meeting_time}`);
                  }
                  console.log(`[ONGOING] ü§ù   - Derived meetingDateTime from history: ${meetingDateTime}`);
                } else {
                  console.warn(`[ONGOING] ü§ù   - Could not derive meeting date/time from history`);
                }
              }
            } catch (err) {
              console.warn(`[ONGOING] ü§ù   - Error while deriving meeting date/time from history`, err);
            }
            
            if (meetingDateTime && !isNaN(meetingDateTime.getTime())) {
              const dateStr = meetingDateTime.toLocaleDateString();
              const timeStr = meetingDateTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              console.log(`[ONGOING] ü§ù   - Using meeting date/time: ${dateStr} ${timeStr}`);
              return `${dateStr} | ${timeStr}<br/>(Mediation day)`;
            }
            // No fallback - if no meeting date available, show error
            console.warn(`[ONGOING] ü§ù   - No meeting_date found for complaint ${complaint.complaint_id} with accepted invitation`);
            return `<span style="color: red;">Missing meeting date</span>`;
          }
          
          else if (actionType.includes('mediation')) {
            // Mediation ‚Üí "Make assessment before:" + 3 days after Date/Time of Meeting
            let baseDate = meetingDateTime || actionDate;
            const deadline = new Date(baseDate.getTime() + (3 * 24 * 60 * 60 * 1000));
            const dateStr = deadline.toLocaleDateString();
            return `Assess before:<br/>${dateStr}`;
          }
          
          else if (actionType.includes('assessment')) {
            // Assessment ‚Üí "Mark as Resolved" in italic
            return `<em>Mark as Resolved</em>`;
          }
          
          // Handle different invitation types - CRITICAL FIX for 'sent invitation' showing wrong deadline
          else if (actionType.includes('sent invitation')) {
            // Sent Invitation ‚Üí 20 days from action_datetime
            console.log(`[ONGOING] üìß SENT INVITATION - Complaint ${complaint.complaint_id}`);
            const deadline = new Date(actionDate.getTime() + (20 * 24 * 60 * 60 * 1000));
            const dateStr = deadline.toLocaleDateString();
            const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            console.log(`[ONGOING] üìß Using 20-day deadline: ${dateStr}`);
            return `${dateStr}<br/>${timeStr}`;
          }
          
          else if (actionType.includes('send invitation') || actionType.includes('invitation')) {
            // Send Invitation (not sent yet) ‚Üí 1 day
            console.log(`[ONGOING] üì§ SEND INVITATION - Complaint ${complaint.complaint_id}`);
            const deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
            const dateStr = deadline.toLocaleDateString();
            const timeStr = actionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            console.log(`[ONGOING] üì§ Using 1-day deadline: ${dateStr}`);
            return `${dateStr}<br/>${timeStr}`;
          }
          
          // Default fallback for other action types
          else {
            console.log(`[ONGOING] ‚ùì UNKNOWN ACTION TYPE - Complaint ${complaint.complaint_id}: "${actionType}"`);
            const deadline = new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
            const dateStr = deadline.toLocaleDateString();
            const timeStr = deadline.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            return `${dateStr}<br/>${timeStr}`;
          }
        };
        
        row.innerHTML = `
          <td>${complaint.complaint_id}</td>
          <td>${formatDateWithTimestamp(complaint.date_received)}</td>
          <td>${complaint.complainant_name || complaint.complainant || 'N/A'}</td>
          <td>${complaint.type_of_complaint}</td>
          <td>${complaint.area_name || 'N/A'}</td>
          <td>${complaint.assigned_to || 'N/A'}</td>
          <td>${formatDeadline(complaint)}</td>
          <td>${complaint.latest_action || complaint.action_needed || 'N/A'}</td>
          <td><button class="priority-${(complaint.priority_level || 'minor').toLowerCase()}">${complaint.priority_level || 'Minor'}</button></td>
        `;
        
        // Apply styling based on latest action AFTER setting innerHTML
        const latestAction = (complaint.latest_action || complaint.action_needed || '').toLowerCase();
        if (latestAction.includes('inspection')) {
          row.classList.add('status-inspection');
          row.style.backgroundColor = '#A7D8F2'; // Light blue for inspection/inspection done
        } else if (latestAction.includes('invitation')) {
          row.classList.add('status-invitation');
          row.style.backgroundColor = '#9FE2BF'; // Light green for invitation/sent invitation
        } else if (latestAction.includes('mediation')) {
          row.classList.add('status-mediation');
          row.style.backgroundColor = '#C9B6E4'; // Light purple for mediation
        } else if (latestAction.includes('assessment')) {
          row.classList.add('status-assessment');
          row.style.backgroundColor = '#B5E48C'; // Light green for assessment
        }
        // If Accepted Invitation but the payload lacked meeting info, try resolving from timeline
        if (latestAction.includes('accepted invitation')) {
          const deadlineCell = row.cells && row.cells[6] ? row.cells[6] : row.querySelector('td:nth-child(7)');
          resolveAcceptedInvitationDeadline(complaint.complaint_id, deadlineCell);
        }
        
        tbody.appendChild(row);
        } catch (error) {
          console.error(`Error processing complaint ${index + 1}:`, error);
          console.error('Complaint data:', complaint);
        }
      });
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      loadOngoingComplaints();
      loadStats();
    });
  </script>

</body>
</html>
