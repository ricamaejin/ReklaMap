<!-- connect to db: areas (search: areas, block?, lot?, ben?) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/admin.css">
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/admin/dashboard" class="nav-item active">Map</a>
      <a href="/admin/complaints/all.html" class="nav-item">Complaints</a>
      <a href="/admin/database/beneficiaries.html" class="nav-item">Beneficiaries</a>
      <a href="/admin/database/policies.html" class="nav-item">Policies</a>
    </nav>
  </aside>

  <!-- User Dropdown -->
  <div class="user-dropdown">
    <!-- Clickable inbox bubble (left side) -->
    <button id="inbox-bubble"
            class="notif-bubble"
            style="display:none;"
            title="Open Inbox"
            aria-label="Open inbox notifications"
            type="button">0</button>

    Logged in as: <span class="username" id="admin-name"></span>
    <button class="dropdown-toggle">▼</button>
    <div class="dropdown-menu">
      <a href="#" id="inboxLink">Inbox <span id="inboxMenuCount" class="notif-count">0</span></a>
      <a href="/portal/index.html">Logout</a>
    </div>
  </div>

  <!-- Main Content -->
  <main class="main-content">
    <header class="main-header">
      <h1>National Government Center Areas</h1>
      <p>
        RA 9207, passed in 2003, authorized the disposition of 422 hectares in the <br />
        NGC, granting land ownership to 5,678 residents of Barangay Holy Spirit <br />
        and other nearby communities.
      </p>
    </header>

    <!-- Search -->
    <div class="search-bar" style="position: relative;">
      <input type="text" id="search-input" placeholder="Search..." style="padding-right: 30px;" />
      <button id="clear-btn" style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 16px; color: #666; cursor: pointer; padding: 0; width: 20px; height: 20px;">×</button>
      <div id="search-results" class="search-results" style="display: none;"></div>
    </div>

    <!-- Map container -->
    <div class="map-section">
      <div id="map-container"></div>
    </div>

    <!-- Tooltip for hover -->
    <div id="tooltip" class="tooltip"></div>
  </main>

  <!-- Inbox Modal -->
  <div class="modal-overlay" id="inboxModal" style="display:none;">
    <div class="inbox-panel">
      <div class="inbox-header">
        <div style="font-weight:700;">Inbox — Tasks Due Soon</div>
        <button class="btn" onclick="closeInbox()">Close</button>
      </div>
      <div id="inboxList" class="inbox-list">
        <div class="inbox-empty">No tasks due soon.</div>
      </div>
      <div class="inbox-footer">
        <button class="btn" onclick="closeInbox()">OK</button>
      </div>
    </div>
  </div>

  <script>
    // Load admin name dynamically
    async function loadAdminName() {
      try {
        const response = await fetch('/admin/current-user');
        if (response.ok) {
          const data = await response.json();
          document.getElementById('admin-name').textContent = data.name || 'Unknown Admin';
        } else {
          document.getElementById('admin-name').textContent = 'Unknown Admin';
        }
      } catch (error) {
        console.error('Error loading admin name:', error);
        document.getElementById('admin-name').textContent = 'Unknown Admin';
      }
    }

    // Cache for area data to prevent repeated API calls
    const areaDataCache = new Map();
    
    // Function to fetch area data from database with caching
    async function fetchAreaData(areaCode) {
      if (areaDataCache.has(areaCode)) {
        return areaDataCache.get(areaCode);
      }
      
      try {
        const response = await fetch(`/admin/areas/stats/${encodeURIComponent(areaCode)}`);
        if (response.ok) {
          const data = await response.json();
          areaDataCache.set(areaCode, data);
          return data;
        }
        return null;
      } catch (error) {
        console.error('Error fetching area data:', error);
        return null;
      }
    }

      // Available SVG files in the /svg folder
    const availableSvgFiles = ['asc', 'beb', 'cen', 'dj1', 'dvm', 'esc', 'lbf', 'lsc', 'sd1', 'sht', 'sjc'];

    // Function to check if an area has a corresponding SVG file
    function hasCorrespondingSvg(areaCode) {
      return availableSvgFiles.includes(areaCode.toLowerCase());
    }

    // Load the SVG map
    function initMap() {
      fetch('/admin/map/svg/hoa_map.svg')
        .then(res => res.text())
        .then(svg => {
          const container = document.getElementById('map-container');
          container.innerHTML = svg;

          const tooltip = document.getElementById('tooltip');
          const svgEl = container.querySelector('svg');

          // Loop through all group areas
          container.querySelectorAll('g').forEach(area => {
            const areaCode = area.id || area.getAttribute('data-name') || area.getAttribute('name') || 'unknown';
            const areaName = area.getAttribute('name')?.toLowerCase();

            // Check if this area has a corresponding SVG file
            const hasCorrespodingSvgFile = hasCorrespondingSvg(areaCode);

            if (areaName && areaData[areaName]) {
              const { name, beneficiaries, complaints, resolved } = areaData[areaName];
              area.dataset.name = name;
              area.dataset.beneficiaries = beneficiaries;
              area.dataset.complaints = complaints;
              area.dataset.resolved = resolved;
            }

            // Only add interactive functionality if corresponding SVG file exists
            if (hasCorrespodingSvgFile) {
              // Tooltip on hover with database data and debouncing to fix glitching
              let tooltipTimeout;
              let currentAreaData = null;
              
              area.addEventListener('mouseenter', async e => {
                // Fetch real data from database
                currentAreaData = await fetchAreaData(areaCode);
                
                // Use area_name from database, fallback to SVG attribute
                const areaName = currentAreaData ? currentAreaData.area_name : (area.getAttribute('name') || area.id || 'Unknown Area');
                const beneficiaries = currentAreaData ? currentAreaData.beneficiaries : 'N/A';
                const complaints = currentAreaData ? currentAreaData.complaints : 'N/A';
                const resolved = currentAreaData ? currentAreaData.resolved : 'N/A';
                
                tooltip.innerHTML = `
                  <div class="tooltip-content">
                    <div class="area-name">
                      <span class="area-text">${areaName}</span>
                    </div>
                    <div class="data-line">
                      <span class="data-icon">👥</span>
                      <span class="data-label">Beneficiaries</span>
                      <span class="data-value">${beneficiaries}</span>
                    </div>
                    <div class="data-line">
                      <span class="data-icon">📋</span>
                      <span class="data-label">Complaints</span>
                      <span class="data-value">${complaints}</span>
                    </div>
                    <div class="data-line">
                      <span class="data-icon">✅</span>
                      <span class="data-label">Resolved</span>
                      <span class="data-value">${resolved}</span>
                    </div>
                  </div>
                `;
                tooltip.style.display = 'block';
              });
              
              area.addEventListener('mousemove', e => {
                if (tooltip.style.display === 'block') {
                  // Position tooltip directly beside mouse cursor with minimal offset
                  const tooltipWidth = 220; // tooltip width from CSS
                  const tooltipHeight = 180; // approximate tooltip height
                  const margin = 10; // small margin to prevent cursor overlap
                  
                  // Use pageX and pageY for accurate positioning relative to document
                  let left = e.pageX + margin;
                  let top = e.pageY + margin;
                  
                  // Prevent tooltip from going off-screen
                  const viewportWidth = window.innerWidth;
                  const viewportHeight = window.innerHeight;
                  const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                  const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                  
                  // Flip to left side of cursor if would go off right edge
                  if (left + tooltipWidth > scrollX + viewportWidth) {
                    left = e.pageX - tooltipWidth - margin;
                  }
                  
                  // Flip to top of cursor if would go off bottom edge
                  if (top + tooltipHeight > scrollY + viewportHeight) {
                    top = e.pageY - tooltipHeight - margin;
                  }
                  
                  // Ensure tooltip stays within viewport bounds as final safeguard
                  left = Math.max(scrollX + 5, Math.min(left, scrollX + viewportWidth - tooltipWidth - 5));
                  top = Math.max(scrollY + 5, Math.min(top, scrollY + viewportHeight - tooltipHeight - 5));
                  
                  tooltip.style.left = left + 'px';
                  tooltip.style.top = top + 'px';
                }
              });

              // Hide tooltip when leaving
              area.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
              });

              // Click navigation
              area.addEventListener('click', () => {
                // Navigate to Flask route /admin/map/<area_code> for dynamic loading
                window.location.href = `/admin/map/${encodeURIComponent(areaCode.toLowerCase())}`;
              });
              
              // Add visual indicator that this area is interactive
              area.style.cursor = 'pointer';
            } else {
              // Disable interactivity for areas without corresponding SVG files
              area.style.cursor = 'default';
              area.style.opacity = '0.7'; // Optional: make non-interactive areas slightly transparent
            }
          });

          // Zoom effect on hover with mouse-follow (only for areas with corresponding SVG files)
          container.querySelectorAll('g').forEach(area => {
            const areaCode = area.id || area.getAttribute('data-name') || area.getAttribute('name') || 'unknown';
            const hasCorrespodingSvgFile = hasCorrespondingSvg(areaCode);
            
            // Only add zoom effect and hover if area has corresponding SVG file
            if (hasCorrespodingSvgFile) {
              let zoomTimeout;

              area.addEventListener('mouseenter', (e) => {
                zoomTimeout = setTimeout(() => {
                  const rect = svgEl.getBoundingClientRect();
                  const offsetX = e.clientX - rect.left; 
                  const offsetY = e.clientY - rect.top;

                  const percentX = (offsetX / rect.width) * 100;
                  const percentY = (offsetY / rect.height) * 100;

                  svgEl.style.transition = "transform 0.8s ease-in-out";
                  svgEl.style.transformOrigin = `${percentX}% ${percentY}%`;
                  svgEl.style.transform = "scale(1.5)";
                }, 200);
              });

              area.addEventListener('mousemove', (e) => {
                // update origin as the mouse moves while zoomed in
                if (svgEl.style.transform === "scale(1.5)") {
                  const rect = svgEl.getBoundingClientRect();
                  const offsetX = e.clientX - rect.left; 
                  const offsetY = e.clientY - rect.top;

                  const percentX = (offsetX / rect.width) * 100;
                  const percentY = (offsetY / rect.height) * 100;

                  svgEl.style.transformOrigin = `${percentX}% ${percentY}%`;
                }
              });

              area.addEventListener('mouseleave', () => {
                clearTimeout(zoomTimeout);
                svgEl.style.transform = "scale(1)";
              });
            }
          });
        })
      .catch(err => console.error("Error loading SVG:", err));
    }

    // Function to initialize dropdown
    function initDropdown() {
      const dropdown = document.querySelector(".user-dropdown");
      const toggle = dropdown.querySelector(".dropdown-toggle");

      toggle.addEventListener("click", (e) => {
        e.stopPropagation();
        dropdown.classList.toggle("active");
      });

      document.addEventListener("click", () => {
        dropdown.classList.remove("active");
      });
    }

    // Search functionality - only search for areas with SVG files
    async function searchDatabase(query) {
      try {
        console.log('Making fetch request to:', `/admin/search?q=${encodeURIComponent(query)}`);
        const response = await fetch(`/admin/search?q=${encodeURIComponent(query)}`);
        console.log('Response status:', response.status);
        if (response.ok) {
          const data = await response.json();
          console.log('Response data:', data);
          // Filter to only include areas that have corresponding SVG files and match word boundaries
          const filteredData = data.filter(result => {
            if (result.type === 'area') {
              const areaCode = result.area_code?.toLowerCase();
              const areaName = (result.area_name || '').toLowerCase();
              const words = areaName.split(/\s+/);
              const matchesQuery = words.some(word => word.startsWith(query.toLowerCase()));
              return availableSvgFiles.includes(areaCode) && matchesQuery;
            }
            return false; // Only show areas, no beneficiaries or blocks
          });
          return filteredData;
        }
        console.error('Response not ok:', response.status, response.statusText);
        return [];
      } catch (error) {
        console.error('Error searching database:', error);
        return [];
      }
    }

    function initSearch() {
      console.log('initSearch called');
      const searchInput = document.getElementById('search-input');
      const clearBtn = document.getElementById('clear-btn');
      const searchResults = document.getElementById('search-results');
      
      console.log('Search elements found:', {
        searchInput: !!searchInput,
        clearBtn: !!clearBtn,
        searchResults: !!searchResults
      });
      
      if (!searchInput || !clearBtn || !searchResults) {
        console.error('Search elements not found!');
        return;
      }
      
      let searchTimeout;
      let selectedIndex = -1;
      let currentResults = [];

      async function performSearch() {
        const query = searchInput.value.trim();
        console.log('performSearch called with query:', query);
        
        // Show/hide clear button based on input
        clearBtn.style.display = query.length > 0 ? 'block' : 'none';
        
        if (query.length < 2) {
          console.log('Query too short, hiding results');
          searchResults.style.display = 'none';
          currentResults = [];
          selectedIndex = -1;
          return;
        }

        // Show loading state
        console.log('Showing loading state and making search request');
        searchResults.innerHTML = '<div class="search-result-item no-results">Searching...</div>';
        searchResults.style.display = 'block';
        console.log('Search results element after setting display block:', {
          display: searchResults.style.display,
          visibility: searchResults.style.visibility,
          zIndex: window.getComputedStyle(searchResults).zIndex,
          position: window.getComputedStyle(searchResults).position
        });

        try {
          const results = await searchDatabase(query);
          console.log('Got search results:', results);
          currentResults = results;
          selectedIndex = -1;
          displaySearchResults(results, query);
        } catch (error) {
          console.error('Search error:', error);
          searchResults.innerHTML = '<div class="search-result-item no-results">Search error occurred</div>';
          searchResults.style.display = 'block';
        }
      }

      function displaySearchResults(results, query) {
        console.log('displaySearchResults called with:', results.length, 'results');
        if (results.length === 0) {
          console.log('No results found, showing no results message');
          searchResults.innerHTML = '<div class="search-result-item no-results">No results found</div>';
          searchResults.style.display = 'block';
          return;
        }

        const resultsHtml = results.map((result, index) => {
          let displayText = '';
          let navigateUrl = '';
          
          if (result.type === 'area') {
            displayText = `📍 ${result.area_name}`;
            const areaCode = result.area_code?.toLowerCase();
            navigateUrl = `/admin/map/${areaCode}`; // Navigate to Flask route
          }
          
          return `<div class="search-result-item" data-index="${index}" data-url="${navigateUrl}" onclick="navigateToResult('${navigateUrl}')">${displayText}</div>`;
        }).join('');

        console.log('Setting search results HTML:', resultsHtml);
        searchResults.innerHTML = resultsHtml;
        searchResults.style.display = 'block';
        console.log('Search results displayed, element visibility:', searchResults.style.display);
      }

      function updateSelection() {
        const items = searchResults.querySelectorAll('.search-result-item:not(.no-results)');
        items.forEach((item, index) => {
          item.classList.toggle('selected', index === selectedIndex);
        });
      }

      function clearSearch() {
        searchInput.value = '';
        searchResults.style.display = 'none';
        clearBtn.style.display = 'none';
        currentResults = [];
        selectedIndex = -1;
        searchInput.focus();
      }

      // Input event for auto-suggestions
      searchInput.addEventListener('input', (e) => {
        console.log('Input event fired, value:', e.target.value);
        const query = e.target.value.trim();
        clearBtn.style.display = query.length > 0 ? 'block' : 'none';
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(performSearch, 300);
      });

      // Clear button functionality
      clearBtn.addEventListener('click', (e) => {
        e.preventDefault();
        clearSearch();
      });

      // Keyboard navigation
      searchInput.addEventListener('keydown', (e) => {
        const items = searchResults.querySelectorAll('.search-result-item:not(.no-results)');
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
          updateSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, -1);
          updateSelection();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedIndex >= 0 && items[selectedIndex]) {
            const url = items[selectedIndex].dataset.url;
            if (url) {
              navigateToResult(url);
            }
          }
        } else if (e.key === 'Escape') {
          clearSearch();
        }
      });

      // Hide results when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-bar')) {
          searchResults.style.display = 'none';
          selectedIndex = -1;
        }
      });

      // Show clear button on focus if there's text
      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim().length > 0) {
          clearBtn.style.display = 'block';
        }
      });
    }

    // Navigate to search result
    function navigateToResult(url) {
      window.location.href = url;
    }

    // ============================
    // Admin Inbox (due soon) logic
    // ============================
    let adminAssignedCache = [];
    const ADMIN_INBOX_THRESHOLD_DAYS = 3; // inclusive: show <= 3 days, including past due and 1 day left

    // Normalize complaint fields from various endpoints to a common shape
    function normalizeComplaint(raw) {
      return {
        complaint_id: raw.complaint_id || raw.id || raw.complaintId,
        complaint_stage: raw.complaint_stage || raw.stage || raw.status || '',
        status: raw.status || '',
        latest_action: raw.latest_action || raw.action_type || raw.action || raw.action_needed || '',
        action_datetime: raw.action_datetime || raw.last_action_datetime || raw.updated_at || raw.actionDateTime || '',
        date_received: raw.date_received || raw.submitted_at || raw.created_at || raw.createdAt || '',
        complainant: raw.complainant_name || raw.complainant || raw.fullname || '',
        area_name: raw.area_name || raw.area || raw.areaName || '',
        // prefer explicit deadlines if backend provides them
        deadline: raw.deadline || raw.action_deadline || raw.deadline_at || raw.due_date || raw.due_at || ''
      };
    }

    // Calculate deadline using the same logic as the Deadline column in complaints table
    function adminGetDeadlineDate(complaint) {
      if (!complaint) return null;

      // Only show deadlines for Pending or Ongoing complaints
      if (complaint.complaint_stage === 'Resolved') return null;
      if ((complaint.status || '').toLowerCase().includes('invalid')) return null;
      if ((complaint.status || '').toLowerCase().includes('resolved')) return null;

      // Filter to only Pending or Ongoing complaints
      if (complaint.complaint_stage !== 'Pending' && complaint.complaint_stage !== 'Ongoing') return null;

      // For Pending complaints
      if (complaint.complaint_stage === 'Pending' || !complaint.latest_action) {
        const submittedDate = new Date(complaint.date_received);
        if (isNaN(submittedDate.getTime())) return null;
        // 6 days after submission (same as Deadline column logic)
        return new Date(submittedDate.getTime() + 6 * 24 * 60 * 60 * 1000);
      }

      // For Ongoing complaints - use same logic as Deadline column
      if (!complaint.action_datetime) return null;
      const actionDate = new Date(complaint.action_datetime);
      if (isNaN(actionDate.getTime())) return null;

      const actionType = (complaint.latest_action || '').toLowerCase();

      // Get admin-set deadline for inspection
      let adminDeadline = null;
      if (complaint.deadline) {
        console.log(`[INDEX] Complaint ${complaint.complaint_id}: Using deadline field = "${complaint.deadline}"`);
        adminDeadline = new Date(complaint.deadline);
      } else {
        console.log(`[INDEX] Complaint ${complaint.complaint_id}: No deadline field found, using fallback`);
      }

      // Get meeting datetime from invitation action
      let meetingDateTime = null;
      if (complaint.meeting_datetime) {
        meetingDateTime = new Date(complaint.meeting_datetime);
      } else if (complaint.meeting_date && complaint.meeting_time) {
        meetingDateTime = new Date(`${complaint.meeting_date}T${complaint.meeting_time}`);
      }

      // Calculate deadline based on action type (same as Deadline column)
      if (actionType.includes('inspection') && !actionType.includes('done')) {
        return adminDeadline || new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
      } else if (actionType.includes('inspection done')) {
        return new Date(actionDate.getTime() + (3 * 24 * 60 * 60 * 1000));
      } else if (actionType.includes('send invitation') || (actionType.includes('invitation') && !actionType.includes('sent') && !actionType.includes('accepted'))) {
        return new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
      } else if (actionType.includes('sent invitation')) {
        return new Date(actionDate.getTime() + (20 * 24 * 60 * 60 * 1000));
      } else if (actionType.includes('accepted invitation')) {
        return meetingDateTime || actionDate;
      } else if (actionType.includes('mediation')) {
        const baseDate = meetingDateTime || actionDate;
        return new Date(baseDate.getTime() + (3 * 24 * 60 * 60 * 1000));
      } else if (actionType.includes('assessment')) {
        return null; // Assessment has no deadline
      } else {
        return new Date(actionDate.getTime() + (1 * 24 * 60 * 60 * 1000));
      }
    }

    // Compute days left until deadline
function adminGetDaysLeft(deadline) {
  if (!deadline) return null;
  const now = new Date();
  
  // Normalize dates to compare only the date part (ignore time) - consistent with assigned.html and all.html
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  const deadlineDate = new Date(deadline.getFullYear(), deadline.getMonth(), deadline.getDate(), 0, 0, 0, 0);
  
  const timeDiff = deadlineDate.getTime() - today.getTime();
  return Math.round(timeDiff / (1000 * 60 * 60 * 24));
}

// Build list of items that are due in <=3 days (inclusive) or overdue
function adminBuildDueSoonItems(complaints) {
  const items = [];
  complaints.forEach(raw => {
    const c = normalizeComplaint(raw);
    const deadline = adminGetDeadlineDate(c);
    if (!deadline) return;

    const daysLeft = adminGetDaysLeft(deadline);
    if (daysLeft === null) return;

    // Include if overdue (daysLeft < 0) or due soon (<=3 days)
    if (daysLeft <= ADMIN_INBOX_THRESHOLD_DAYS) {
      const isPending = (c.complaint_stage === 'Pending') || !c.latest_action;
      items.push({ complaint: c, deadline, daysLeft, isPending });
    }
  });

  // Sort: overdue first, then soonest due
  items.sort((a, b) => a.daysLeft - b.daysLeft);
  return items;
}

    function adminResolveDetailsLink(complaintId) {
      return `/admin/complaints/complaint_details_valid.html?id=${complaintId}`;
    }

    async function openInbox() {
      const listEl = document.getElementById('inboxList');
      const items = adminBuildDueSoonItems(adminAssignedCache);

      if (!items.length) {
        listEl.innerHTML = '<div class="inbox-empty">No tasks due soon.</div>';
      } else {
        const rows = items.map(({ complaint, deadline, daysLeft, isPending }) => {
          const link = adminResolveDetailsLink(complaint.complaint_id);
          const when = deadline.toLocaleString(undefined, {
            year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
          });

          const pillClass = daysLeft < 0 ? 'pill-overdue' : (daysLeft <= ADMIN_INBOX_THRESHOLD_DAYS ? 'pill-soon' : 'pill-ok');
          const pillText = daysLeft < 0 ? `Overdue by ${Math.abs(daysLeft)}d` : (daysLeft === 0 ? 'Due today' : `${daysLeft}d left`);

          const stage = isPending
            ? 'Pending'
            : (complaint.complaint_stage || (complaint.latest_action || 'Ongoing'));

          const who = complaint.complainant_name || complaint.complainant || 'Complainant';
          const area = complaint.area_name ? ` • ${complaint.area_name}` : '';
          const reason = isPending ? 'Submitted deadline' : (complaint.latest_action || complaint.action_needed || 'Ongoing');

          return `
            <div class="inbox-item" onclick="window.location.href='${link}'">
              <span class="inbox-pill ${pillClass}">${pillText}</span>
              <div>
                <div class="inbox-title">${stage}</div>
                <div class="inbox-meta">ID #${complaint.complaint_id} • ${who}${area}</div>
                <div class="inbox-meta">Deadline: ${when} • ${reason}</div>
              </div>
            </div>
          `;
        });
        listEl.innerHTML = rows.join('');
      }

      document.getElementById('inboxModal').style.display = 'flex';
    }

    function closeInbox() {
      document.getElementById('inboxModal').style.display = 'none';
    }

    // Add the missing dropdown/bubble wiring for the inbox
    function initInboxDropdown() {
      const link = document.getElementById('inboxLink');
      if (link) {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openInbox();
        });
      }

      const bubbleBtn = document.getElementById('inbox-bubble');
      if (bubbleBtn) {
        bubbleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openInbox();
        });
        bubbleBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            openInbox();
          }
        });
      }

      const inboxModal = document.getElementById('inboxModal');
      if (inboxModal) {
        inboxModal.addEventListener('click', (e) => {
          if (e.target === inboxModal) closeInbox();
        });
      }

      // Periodic badge refresh
      setInterval(updateInboxBadge, 60_000);
    }

    function updateInboxBadge() {
      const items = adminBuildDueSoonItems(adminAssignedCache);
      const count = items.length;
      const bubble = document.getElementById('inbox-bubble');
      const menuCount = document.getElementById('inboxMenuCount');

      if (count > 0) {
        bubble.style.display = 'inline-flex';
        bubble.textContent = String(count);
        bubble.setAttribute('aria-hidden', 'false');
        bubble.setAttribute('aria-label', `Open inbox, ${count} task${count>1?'s':''} due soon`);
        if (menuCount) {
          menuCount.textContent = String(count);
          menuCount.style.display = 'inline-flex';
        }
      } else {
        bubble.style.display = 'none';
        bubble.setAttribute('aria-hidden', 'true');
        if (menuCount) {
          menuCount.textContent = '0';
          menuCount.style.display = 'none';
        }
      }
    }

    // Try several endpoints; take the first that returns a non-empty list
    async function loadAdminAssignedForInbox() {
      const urls = [
        `/admin/complaints/api/assigned?_=${Date.now()}`,
        `/admin/complaints/api/ongoing?_=${Date.now()}`,
        `/admin/complaints/api/all?_=${Date.now()}`
      ];
      let loaded = false;

      for (const url of urls) {
        try {
          const res = await fetch(url);
          if (!res.ok) continue;
          const data = await res.json();
          const list = Array.isArray(data)
            ? data
            : (Array.isArray(data.complaints) ? data.complaints : (Array.isArray(data.items) ? data.items : []));

          if (list.length) {
            adminAssignedCache = list;
            loaded = true;
            break;
          }
        } catch (_) { /* try next */ }
      }

      // Fallback: also try staff view if admin endpoints empty
      if (!loaded) {
        try {
          const res = await fetch(`/staff/api/complaints/assigned?_=${Date.now()}`);
          if (res.ok) {
            const data = await res.json();
            adminAssignedCache = Array.isArray(data.complaints) ? data.complaints : [];
          } else {
            adminAssignedCache = [];
          }
        } catch (_) {
          adminAssignedCache = [];
        }
      }

      updateInboxBadge();
    }

    async function initAdminInbox() {
      await loadAdminAssignedForInbox();
      // Refresh list every 3 minutes; badge every minute
      setInterval(loadAdminAssignedForInbox, 180_000);
      setInterval(updateInboxBadge, 60_000);
    }

    // Run everything on DOM load
    document.addEventListener("DOMContentLoaded", () => {
      loadAdminName();
      initMap();
      initDropdown();
      initSearch();

      // Inbox init
      initInboxDropdown();
      initAdminInbox();
    });
  </script>

  <style>
    /* Enhanced tooltip styling with icons and uniform appearance */
    .tooltip {
      position: fixed;
      width: 220px;
      min-height: 140px;
      max-height: 180px;
      padding: 12px 14px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.98));
      color: #1e293b;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(203, 213, 225, 0.8);
      pointer-events: none;
      z-index: 1000;
      backdrop-filter: blur(12px);
      transform: translateY(-5px);
      opacity: 0.95;
      overflow: hidden;
    }

    .tooltip-content {
      display: block;
    }

    .tooltip .area-name {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 8px;
      color: rgb(15, 39, 97);
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 6px;
      min-height: 32px;
    }

    .tooltip .area-text {
      flex: 1;
      word-wrap: break-word;
      line-height: 1.3;
      max-height: 52px;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      text-align: center;
    }

    .tooltip .data-line {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      margin: 4px 0;
      padding: 2px 0;
    }

    .tooltip .data-line:last-child {
      margin-bottom: 0;
    }

    .tooltip .data-icon {
      font-size: 12px;
      width: 16px;
      text-align: center;
    }

    .tooltip .data-label {
      color: #293647;
      font-weight: 700;
      flex: 1;
    }

    .tooltip .data-value {
      color: #0f172a;
      font-weight: 700;
      min-width: 40px;
      text-align: right;
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
    }

    /* Search functionality styles */
    .search-bar {
      position: relative !important;
      display: inline-block !important;
      width: 400px !important;
      margin-bottom: 20px !important;
      overflow: visible !important; /* Override the hidden overflow from admin.css */
      background-color: transparent !important;
      box-shadow: none !important;
      border-radius: 0 !important;
    }

    #search-input {
      width: 100%;
      padding: 10px 40px 10px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
    }

    #search-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 4px;
    }

    .search-result-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background-color 0.2s ease;
      font-size: 14px;
      line-height: 1.4;
    }

    .search-result-item:hover,
    .search-result-item.selected {
      background-color: #f8f9fa;
    }

    .search-result-item.selected {
      background-color: #e3f2fd;
      border-left: 3px solid #2196f3;
    }

    .search-result-item:last-child {
      border-bottom: none;
    }

    .search-result-item.no-results {
      color: #666;
      text-align: center;
      font-style: italic;
      cursor: default;
    }

    .search-result-item.no-results:hover {
      background-color: transparent;
    }

    /* Inbox bubble and counts */
    .notif-bubble {
      background: #e53935;
      color: #fff;
      border-radius: 12px;
      padding: 0 8px;
      font-size: 11px;
      line-height: 20px;
      height: 20px;
      min-width: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      cursor: pointer;
      border: none;
      outline: none;
      margin-right: 6px; /* bubble on the left side of label */
    }
    .notif-bubble:focus {
      box-shadow: 0 0 0 2px rgba(229,57,53,0.25);
    }
    .dropdown-menu a#inboxLink {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .notif-count {
      background: #e53935;
      color: #fff;
      border-radius: 12px;
      padding: 0 6px;
      font-size: 11px;
      line-height: 18px;
      height: 18px;
      min-width: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
    }

    /* Inbox modal */
    #inboxModal.modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .inbox-panel {
      width: 520px;
      max-width: 95vw;
      max-height: 80vh;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .inbox-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-bottom: 1px solid #eee;
      background: #f8f9fa;
    }
    .inbox-list {
      overflow: auto;
      padding: 8px 0;
    }
    .inbox-item {
      padding: 12px 16px;
      border-bottom: 1px solid #f1f1f1;
      display: flex;
      gap: 12px;
      align-items: flex-start;
      cursor: pointer;
    }
    .inbox-item:hover { background: #fafafa; }
    .inbox-pill {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 700;
      color: #fff;
      white-space: nowrap;
    }
    .pill-overdue { background: #d32f2f; }
    .pill-soon { background: #f57c00; }
    .pill-ok { background: #43a047; }
    .inbox-title {
      font-weight: 700;
      color: #001241;
      margin-bottom: 2px;
    }
    .inbox-meta {
      font-size: 12px;
      color: #555;
    }
    .inbox-empty {
      text-align: center;
      color: #666;
      padding: 24px;
    }
    .inbox-footer {
      padding: 10px 16px;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      background: #f8f9fa;
    }
    .btn {
      border: 1px solid #ccc;
      background: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    .btn:hover { background: #f5f5f5; }
  </style>
</body>
</html>
