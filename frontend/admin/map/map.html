<!-- connect to db: areas, blocks, beneficiaries, complaints -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/areas.css">
  <link rel="stylesheet" href="/css/admin.css">
</head>
<body>

  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/admin/dashboard" class="nav-item active">Map</a>
      <a href="/admin/complaints/all.html" class="nav-item">Complaints</a>
      <a href="/admin/database/beneficiaries.html" class="nav-item">Beneficiaries</a>
      <a href="/admin/database/policies.html" class="nav-item">Policies</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">

    <!-- Header -->
    <header class="page-header" style="margin-top: -10px; padding-top: 0px;">
      <div class="header-content">
        <div class="header-left">
          <button class="back-arrow" onclick="goBack()" title="Back to Map">◀</button>
          <h1 id="area-title">Loading...</h1>
        </div>
        <div class="header-right">
          <div class="search-bar" style="position: relative;">
            <input type="text" id="search-input" placeholder="Search residents..." style="padding-right: 30px;"/>
            <button id="clear-btn" style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 16px; color: #666; cursor: pointer; padding: 0; width: 20px; height: 20px;">×</button>
            <div id="search-results" class="search-results" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 9999; margin-top: 4px;"></div>
          </div>
        </div>
      </div>
    </header>

    <div class="map-layout">

      <div class="map-section">
        <div id="map-container">
          <div class="map-legend" id="map-legend" aria-hidden="false">
            <!-- Dynamic blocks legend will be populated here -->
          </div>
        </div>
      </div>

      <!-- Info + Table -->
      <div class="side-panel">
        <!-- Info Card -->
        <div class="info-card">
          <h2 id="president-name">Loading...</h2>
          <div class="info-grid">
            <div class="info-left">
              <span id="president-address">Loading...</span><br>
              <span id="president-contact">Loading...</span>
            </div>
            <div class="info-right">
              <strong>Blocks:</strong> <span id="total-blocks">0</span><br>
              <strong>Members:</strong> <span id="total-members">0</span>
            </div>
          </div>
        </div>

        <!-- Residents List -->
        <div class="list-table">
          <div class="table-header">
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Block
                    <button class="filter-btn" aria-label="Filter Block">&#x25BC;</button>
                    <ul class="filter-menu" hidden>
                      <li data-filter="all">All</li>
                      <!-- Dynamic block options will be populated here -->
                    </ul>
                  </th>
                  <th>Lot No.</th>
                  <th>Area</th>
                </tr>
              </thead>
            </table>
          </div>
          <div class="table-body">
            <table>
              <tbody id="resident-table">
                <!-- Dynamic data will be populated here -->
              </tbody>
            </table>
          </div>
        </div>

        <!-- Stats -->
        <div class="stats-section">
          <div class="stat-card">
            <i class="bi bi-graph-up-arrow"></i>
            <div>
              <h3 id="total-complaints">0</h3>
              <p>Complaints</p>
            </div>
          </div>
          
          <div class="stat-card">
            <i class="bi bi-person-exclamation"></i>
            <div>
              <h3 id="ongoing-complaints">0</h3>
              <p>On Going</p>   
            </div>
          </div>
          
          <div class="stat-card">
            <i class="bi bi-person-check"></i>
            <div>
             <h3 id="resolved-complaints">0</h3>
              <p>Resolved</p>
            </div>
          </div>
        </div>

      </div>
    </div>

  <!-- Tooltip for hover -->
  <div id="tooltip" class="tooltip"></div>

<script>
(function () {
  // Get area code from URL path
  const pathParts = window.location.pathname.split('/');
  const areaCode = pathParts[pathParts.length - 1];
  
  const container = document.getElementById('map-container');
  const tooltip = document.getElementById('tooltip');
  const residentTable = document.getElementById('resident-table');
  
  // Store area data globally
  let currentAreaData = null;
  let currentBeneficiaries = [];
  let currentBlocks = [];

  if (!container) {
    console.error('No #map-container found');
    return;
  }

  function clearSvgSelection() {
    container.querySelectorAll('svg g').forEach(g => {
      g.classList.remove('selected-area');
      g.querySelectorAll('path, rect, polygon, circle').forEach(el => {
        if (el.dataset.origFill) {
          el.setAttribute('fill', el.dataset.origFill);
        }
      });
    });
  }

  function highlightSvgArea(areaEl) {
    clearSvgSelection();
    if (!areaEl) return;
    areaEl.classList.add('selected-area');

    areaEl.querySelectorAll('path, rect, polygon, circle').forEach(el => {
      el.setAttribute('fill', '#4CAF50');
    });
  }

  function highlightRow(block, lot) {
    residentTable.querySelectorAll('tr').forEach(r => r.classList.remove('highlight'));

    // Find matching row (block_no in col index 1, lot in col index 2)
    const rows = Array.from(residentTable.querySelectorAll('tr'));
    const match = rows.find(row => {
      const rowBlock = row.children[1]?.textContent.trim();
      const rowLot = row.children[2]?.textContent.trim();
      return String(rowBlock) === String(block) && String(rowLot) === String(lot);
    });

    if (match) {
      match.classList.add('highlight');
      match.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Bidirectional highlighting: highlight corresponding SVG area
    const svgGroups = Array.from(container.querySelectorAll('svg g'));
    const matchArea = svgGroups.find(g => {
      const aBlock = parseBlockFromId(g.id);
      const aLot = parseLotFromId(g.id);
      return String(aBlock) === String(block) && String(aLot) === String(lot);
    });

    // Clear previous SVG selections and apply new one
    clearSvgSelection();
    if (matchArea) {
      highlightSvgArea(matchArea);
    }
  }

  function parseBlockFromId(id) {
    if (!id) return null;
    // Try multiple patterns: B1, Block1, blk1, etc.
    const patterns = [
      /B\s*?(\d+)/i,
      /B(\d+)/i,
      /block\s*?(\d+)/i,
      /blk\s*?(\d+)/i,
      /(\d+)/ // fallback: any number
    ];
    
    for (const pattern of patterns) {
      const match = id.match(pattern);
      if (match) return match[1];
    }
    return null;
  }

  function parseLotFromId(id) {
    if (!id) return null;
    // Try multiple patterns: L1, Lot1, lot1, etc.
    const patterns = [
      /L\s*?(\d+)/i,
      /L(\d+)/i,
      /lot\s*?(\d+)/i,
      /(?:B\d+.*?)L(\d+)/i, // Block1Lot5 pattern
      /(?:block\d+.*?)lot(\d+)/i
    ];
    
    for (const pattern of patterns) {
      const match = id.match(pattern);
      if (match) return match[1];
    }
    return null;
  }

  function extractSvgBlockColors() {
    const blockColors = {};
    
    // Only extract colors for blocks that actually exist in our blocks data
    const validBlockNos = currentBlocks.map(b => b.block_no);
    console.log('Valid block numbers from blocks data:', validBlockNos); // Debug log
    
    // First, try to get colors from individual lot elements (groups with both block and lot info)
    const lotGroups = container.querySelectorAll('svg g[id]');
    console.log(`Scanning ${lotGroups.length} SVG groups for lot colors`); // Debug log
    
    lotGroups.forEach(group => {
      const blockNum = parseBlockFromId(group.id);
      const lotNum = parseLotFromId(group.id);
      
      // Only process if this is a valid block number from our blocks data
      if (blockNum && validBlockNos.includes(parseInt(blockNum))) {
        if (!blockColors[blockNum]) {
          // Look for fill colors in the group's children (actual lot shapes)
          const lotShapes = group.querySelectorAll('path, rect, polygon, circle, ellipse');
          
          for (const shape of lotShapes) {
            let fill = shape.getAttribute('fill') || shape.style.fill;
            
            // If no direct fill, check computed style
            if (!fill || fill === 'currentColor' || fill === 'inherit') {
              try {
                const computed = window.getComputedStyle(shape);
                fill = computed.fill;
              } catch (e) {
                // Ignore errors
              }
            }
            
            // Accept valid color values
            if (fill && fill !== 'none' && fill !== 'transparent' && fill !== 'currentColor' && fill !== 'inherit' && !fill.includes('url(')) {
              blockColors[blockNum] = fill;
              console.log(`✓ Found lot color ${fill} for Block ${blockNum} from ${group.id}`); // Debug log
              break; // Use the first valid color found for this block
            }
          }
        }
      }
    });
    
    // If we still don't have colors for some blocks, try broader search
    validBlockNos.forEach(blockNo => {
      if (!blockColors[blockNo]) {
        // Look for any element that might represent this block
        const allElements = container.querySelectorAll('svg *[id]');
        
        for (const element of allElements) {
          const elementBlockNum = parseBlockFromId(element.id);
          if (elementBlockNum && parseInt(elementBlockNum) === blockNo) {
            let fill = element.getAttribute('fill') || element.style.fill;
            
            if (!fill || fill === 'currentColor' || fill === 'inherit') {
              try {
                const computed = window.getComputedStyle(element);
                fill = computed.fill;
              } catch (e) {
                // Ignore errors
              }
            }
            
            if (fill && fill !== 'none' && fill !== 'transparent' && fill !== 'currentColor' && fill !== 'inherit' && !fill.includes('url(')) {
              blockColors[blockNo] = fill;
              console.log(`✓ Fallback color ${fill} for Block ${blockNo} from ${element.id}`); // Debug log
              break;
            }
          }
        }
      }
    });
    
    // Final fallback: assign default colors for blocks without SVG colors
    validBlockNos.forEach((blockNo, index) => {
      if (!blockColors[blockNo]) {
        const fallbackColor = `hsl(${(index * 137.5) % 360}, 65%, 55%)`;
        blockColors[blockNo] = fallbackColor;
        console.log(`⚠ Using fallback color ${fallbackColor} for Block ${blockNo}`); // Debug log
      }
    });
    
    console.log('Final extracted block colors:', blockColors); // Debug log
    return blockColors;
  }

  // Load area data
  async function loadAreaData() {
    try {
      const response = await fetch(`/admin/areas/by_code/${areaCode}`);
      if (!response.ok) {
        throw new Error('Area not found');
      }
      currentAreaData = await response.json();
      
      // Update page title and info
      document.getElementById('area-title').textContent = currentAreaData.area_name;
      document.getElementById('president-name').textContent = currentAreaData.president;
      document.getElementById('president-address').textContent = currentAreaData.designation;
      document.getElementById('president-contact').textContent = currentAreaData.contact_no || 'N/A';
      document.title = `ReklaMap - ${currentAreaData.area_name}`;
      
      // Load beneficiaries first
      await loadBeneficiaries();
      
      // Load blocks (depends on beneficiaries data)
      await loadBlocks();
      
      // Load complaint stats
      await loadComplaintStats();
      
      // Load SVG
      await loadSVG();
      
    } catch (error) {
      console.error('Error loading area data:', error);
      document.getElementById('area-title').textContent = 'Area Not Found';
    }
  }

  async function loadBlocks() {
    try {
      const response = await fetch(`/admin/blocks/area/${currentAreaData.area_id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      currentBlocks = await response.json();
      
      console.log('Loaded blocks:', currentBlocks); // Debug log
      
      // Update total blocks count
      document.getElementById('total-blocks').textContent = currentBlocks.length;
      
      // Update filter dropdown
      updateFilterDropdown();
      
      // Note: generateLegend will be called after SVG is loaded
      
    } catch (error) {
      console.error('Error loading blocks:', error);
      // Fallback to beneficiaries data if blocks API fails
      if (currentBeneficiaries.length > 0) {
        const uniqueBlocks = [...new Set(currentBeneficiaries.map(b => b.block_id))].sort((a, b) => a - b);
        document.getElementById('total-blocks').textContent = uniqueBlocks.length;
        updateFilterDropdown();
        // Note: generateLegend will be called after SVG is loaded
      }
    }
  }

  async function loadBeneficiaries() {
    try {
      const response = await fetch(`/admin/beneficiaries/${currentAreaData.area_id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      currentBeneficiaries = await response.json();
      
      console.log('Loaded beneficiaries:', currentBeneficiaries); // Debug log
      
      // Load member count separately (only beneficiaries with name fields)
      await loadMemberCount();
      
      // Populate table
      populateTable();
      
    } catch (error) {
      console.error('Error loading beneficiaries:', error);
      // Show error in the table
      const tableBody = document.getElementById('resident-table');
      tableBody.innerHTML = `<tr><td colspan="4" style="text-align: center; padding: 20px; color: #ff6b6b;">Error loading beneficiaries: ${error.message}</td></tr>`;
    }
  }

  async function loadMemberCount() {
    try {
      const response = await fetch(`/admin/beneficiaries/count/${currentAreaData.area_id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      
      // Update total members count (only beneficiaries with name fields)
      document.getElementById('total-members').textContent = data.count;
      
    } catch (error) {
      console.error('Error loading member count:', error);
      document.getElementById('total-members').textContent = '0';
    }
  }

  // FIXED: Restored complaint stats function
  async function loadComplaintStats() {
    try {
      const response = await fetch(`/admin/map/api/complaints/${currentAreaData.area_id}`);
      const stats = await response.json();
      
      document.getElementById('total-complaints').textContent = stats.total;
      document.getElementById('resolved-complaints').textContent = stats.resolved;
      document.getElementById('ongoing-complaints').textContent = stats.ongoing;
      
    } catch (error) {
      console.error('Error loading complaint stats:', error);
      // Set default values on error
      document.getElementById('total-complaints').textContent = '0';
      document.getElementById('resolved-complaints').textContent = '0';
      document.getElementById('ongoing-complaints').textContent = '0';
    }
  }

  function generateLegend() {
    const legendContainer = document.getElementById('map-legend');
    
    // Prevent multiple executions if legend is already generated
    if (legendContainer.children.length > 0) {
      console.log('Legend already generated, skipping'); // Debug log
      return;
    }
    
    // Check if we have the required data
    if (!currentBlocks || currentBlocks.length === 0) {
      console.log('No blocks data available for legend'); // Debug log
      return;
    }
    
    // Check if SVG is loaded
    const svgElement = container.querySelector('svg');
    if (!svgElement) {
      console.log('SVG not loaded yet, scheduling legend generation'); // Debug log
      setTimeout(generateLegend, 1000);
      return;
    }
    
    console.log('Generating legend...'); // Debug log
    
    const svgColors = extractSvgBlockColors();
    
    // Use block_no from blocks data (no duplicates possible since it comes from DB)
    const blockNos = currentBlocks.map(b => b.block_no).sort((a, b) => a - b);
    
    console.log('Generating legend for block numbers:', blockNos); // Debug log
    console.log('Available SVG colors:', svgColors); // Debug log
    
    blockNos.forEach((blockNo, i) => {
      const div = document.createElement('div');
      div.style.display = 'flex';
      div.style.alignItems = 'center';
      div.style.marginRight = '15px';
      
      // Create the color box
      const colorBox = document.createElement('span');
      colorBox.classList.add('legend-color');
      
      // Use actual SVG color for this specific block number, or fallback
      const actualColor = svgColors[blockNo] || svgColors[String(blockNo)] || `hsl(${(i * 60) % 360}, 65%, 55%)`;
      colorBox.style.backgroundColor = actualColor;
      
      console.log(`✓ Legend Block ${blockNo} assigned color:`, actualColor); // Debug log
      
      // Add text label
      div.appendChild(colorBox);
      div.append(`BLOCK ${blockNo}`);
      
      // Append to legend container
      legendContainer.appendChild(div);
    });
  }

  function updateFilterDropdown() {
    const filterMenu = document.querySelector('.filter-menu');
    if (!filterMenu) return;
    
    // Clear existing options (keep "All")
    const allOption = filterMenu.querySelector('[data-filter="all"]');
    filterMenu.innerHTML = '';
    filterMenu.appendChild(allOption);
    
    if (!currentBlocks || currentBlocks.length === 0) {
      console.log('No blocks data available for dropdown'); // Debug log
      return;
    }
    
    // Use block_no from blocks data (sorted)
    const blockNos = currentBlocks.map(b => b.block_no).sort((a, b) => a - b);
    
    console.log('Dropdown blocks from blocks data:', blockNos); // Debug log
    
    blockNos.forEach(blockNo => {
      const li = document.createElement('li');
      li.setAttribute('data-filter', blockNo);
      li.textContent = `Block ${blockNo}`;
      filterMenu.appendChild(li);
    });
  }

  function populateTable() {
    const tableBody = document.getElementById('resident-table');
    
    tableBody.innerHTML = '';
    
    console.log('Populating table with:', currentBeneficiaries); // Debug log
    
    if (!currentBeneficiaries || currentBeneficiaries.length === 0) {
      const row = document.createElement('tr');
      row.innerHTML = `<td colspan="4" style="text-align: center; padding: 20px; color: #666;">No data found</td>`;
      tableBody.appendChild(row);
      return;
    }
    
    currentBeneficiaries.forEach((resident, index) => {
      console.log(`Processing resident ${index}:`, resident); // Debug log
      
      const row = document.createElement('tr');
      
      // Use the name directly since backend now handles formatting for both beneficiaries and generated_lots
      const displayName = resident.name || 'Unknown';
      const blockNo = resident.block_no || 'N/A';
      
      // Add visual distinction for generated_lots entries
      const rowClass = resident.source === 'generated_lot' ? 'generated-lot-row' : '';
      if (rowClass) {
        row.classList.add(rowClass);
      }
      
      row.innerHTML = `
        <td style="text-align: left;">${displayName}</td>
        <td>${blockNo}</td>
        <td>${resident.lot_no || 'N/A'}</td>
        <td>${resident.sqm || 'N/A'}</td>
      `;
      
      // Add click handler for row highlighting
      row.addEventListener('click', () => {
        document.querySelectorAll('#resident-table tr').forEach(r => r.classList.remove('highlight'));
        row.classList.add('highlight');
      });
      
      tableBody.appendChild(row);
    });
  }

  async function loadSVG() {
    try {
      const response = await fetch(`/admin/map/svg/${areaCode}.svg`);
      const svgText = await response.text();
      
      container.insertAdjacentHTML('afterbegin', svgText);
      
      // Generate legend after SVG is loaded
      setTimeout(generateLegend, 500);
      
      const svgGroups = container.querySelectorAll('svg g');
      
      const svgEl = container.querySelector('svg'); // Get reference to main SVG for zoom functionality
      
      // Save original fill and setup interactions for groups
      svgGroups.forEach(g => {
        // Check if this element has a "lot" attribute for full interactivity
        const hasLotAttribute = g.hasAttribute('lot');
        
        g.querySelectorAll('path, rect, polygon, circle').forEach(el => {
          el.dataset.origFill = el.getAttribute('fill') || '';
        });

        // Skip ALL interactivity for elements without "lot" attribute
        if (!hasLotAttribute) {
          g.style.cursor = 'default';
          g.style.pointerEvents = 'none'; // Disable all mouse events
          return; // Skip all event listeners for non-lot elements
        }
        
        // Add interactive functionality only for lot elements
        g.style.cursor = 'pointer';

        // Zoom functionality variables
        let zoomTimeout;

        // Zoom on hover (mouseenter)
        g.addEventListener('mouseenter', (e) => {
          zoomTimeout = setTimeout(() => {
            const rect = svgEl.getBoundingClientRect();
            const offsetX = e.clientX - rect.left; 
            const offsetY = e.clientY - rect.top;

            const percentX = (offsetX / rect.width) * 100;
            const percentY = (offsetY / rect.height) * 100;

            svgEl.style.transition = "transform 0.8s ease-in-out";
            svgEl.style.transformOrigin = `${percentX}% ${percentY}%`;
            svgEl.style.transform = "scale(1.5)";
          }, 200);
        });

        // Tooltip hover
        g.addEventListener('mousemove', e => {
          // Update zoom origin while zoomed
          if (svgEl.style.transform === "scale(1.5)") {
            const rect = svgEl.getBoundingClientRect();
            const offsetX = e.clientX - rect.left; 
            const offsetY = e.clientY - rect.top;

            const percentX = (offsetX / rect.width) * 100;
            const percentY = (offsetY / rect.height) * 100;

            svgEl.style.transformOrigin = `${percentX}% ${percentY}%`;
          }

          // Tooltip functionality
          const block = parseBlockFromId(g.id);
          const lot = parseLotFromId(g.id);
          
          let tooltipContent = 'Area Information';
          if (block && lot) {
            // Find beneficiary by matching block_no (from SVG) with block_no (from blocks data)
            const blockData = currentBlocks.find(b => b.block_no == block);
            const beneficiary = blockData ? currentBeneficiaries.find(b => 
              b.block_id == blockData.block_id && b.lot_no == lot
            ) : null;
            
            if (beneficiary) {
              let fullName = beneficiary.first_name || '';
              if (beneficiary.middle_initial) fullName += ` ${beneficiary.middle_initial}`;
              if (beneficiary.last_name) fullName += ` ${beneficiary.last_name}`;
              if (beneficiary.suffix) fullName += ` ${beneficiary.suffix}`;
              tooltipContent = `<div class="tooltip-content"><strong>${fullName.trim()}</strong><br>Block ${block}, Lot ${lot}<br>${beneficiary.sqm} sqm</div>`;
            } else {
              tooltipContent = `<div class="tooltip-content">Block ${block}, Lot ${lot}</div>`;
            }
          }
          
          tooltip.innerHTML = tooltipContent;
          tooltip.style.left = (e.pageX + 12) + 'px';
          tooltip.style.top = (e.pageY + 12) + 'px';
          tooltip.style.display = 'block';
        });

        g.addEventListener('mouseleave', () => {
          // Reset zoom
          clearTimeout(zoomTimeout);
          svgEl.style.transform = "scale(1)";
          
          // Hide tooltip
          tooltip.style.display = 'none';
        });

        // Click highlight row
        g.addEventListener('click', () => {
          
          console.log('SVG clicked:', g.id); // Debug log
          
          let svgBlock = null;
          let svgLot = null;
          
          // Check if this element has a lot attribute
          const lotAttr = g.getAttribute('lot');
          if (lotAttr) {
            svgLot = lotAttr;
            
            // Find the parent block element by traversing up the DOM
            let parentElement = g.parentElement;
            while (parentElement && !svgBlock) {
              if (parentElement.id && parentElement.id.match(/block\s*(\d+)/i)) {
                const blockMatch = parentElement.id.match(/block\s*(\d+)/i);
                svgBlock = blockMatch[1];
                break;
              }
              parentElement = parentElement.parentElement;
            }
          } else {
            // Fallback: try to extract from the element's own id
            const blockMatch = g.id.match(/block\s*(\d+)/i);
            svgBlock = blockMatch ? blockMatch[1] : null;
            
            const lotMatch = g.id.match(/lot\s*(\d+)/i) || g.id.match(/L\s*(\d+)/i);
            svgLot = lotMatch ? lotMatch[1] : null;
          }
          
          console.log('Parsed SVG block:', svgBlock, 'lot:', svgLot); // Debug log
          
          if (svgBlock && svgLot) {
            // Find matching row based on displayed values in Block and Lot No. columns
            const rows = Array.from(residentTable.querySelectorAll('tr'));
            const matchingRow = rows.find(row => {
              const displayedBlock = row.children[1]?.textContent.trim();
              const displayedLot = row.children[2]?.textContent.trim();
              
              // Compare with displayed values (case-insensitive for block)
              return String(displayedBlock).toLowerCase() === String(svgBlock).toLowerCase() && 
                     String(displayedLot) === String(svgLot);
            });
            
            if (matchingRow) {
              // Clear previous highlights
              residentTable.querySelectorAll('tr').forEach(r => r.classList.remove('highlight'));
              
              // Highlight the matching row
              matchingRow.classList.add('highlight');
              matchingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              console.log('Highlighted row for Block:', svgBlock, 'Lot:', svgLot); // Debug log
            } else {
              console.log('No matching row found for Block:', svgBlock, 'Lot:', svgLot); // Debug log
            }
          } else {
            console.log('Could not parse block/lot from SVG structure. Element:', g.id, 'Lot attr:', lotAttr); // Debug log
          }
        });
        
        // Add a function to highlight entire block
        function highlightBlock(blockNo) {
          residentTable.querySelectorAll('tr').forEach(r => r.classList.remove('highlight'));
          
          const rows = Array.from(residentTable.querySelectorAll('tr'));
          rows.forEach(row => {
            const rowBlock = row.children[1]?.textContent.trim();
            if (String(rowBlock) === String(blockNo)) {
              row.classList.add('highlight');
            }
          });
        }
      });
      
    } catch (error) {
      console.error('Error loading SVG:', error);
    }
  }

  // Dropdown & table interactions
  const filterBtn = document.querySelector('.filter-btn');
  const filterMenu = document.querySelector('.filter-menu');

  filterBtn?.addEventListener('click', e => {
    e.stopPropagation();
    filterMenu.hidden = !filterMenu.hidden;
  });

  filterMenu?.addEventListener('click', e => {
    if (e.target.tagName === 'LI') {
      const filterValue = e.target.dataset.filter;
      Array.from(residentTable.querySelectorAll('tr')).forEach(row => {
        const block = row.children[1]?.textContent.trim();
        // Convert both to strings for comparison since filterValue is string and block is displayed as block_no
        row.style.display = (filterValue === 'all' || String(block) === String(filterValue)) ? '' : 'none';
      });
      filterMenu.hidden = true;
    }
  });

  document.addEventListener('click', () => {
    if (filterMenu) filterMenu.hidden = true;
  });

  // clicking a table row highlights SVG
  residentTable.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if (!tr) return;
    const block = tr.children[1]?.textContent.trim();
    const lot = tr.children[2]?.textContent.trim();
    if (block && lot) highlightRow(block, lot);
  });

  // Function to handle URL parameters for highlighting
  function handleUrlHighlighting() {
    const urlParams = new URLSearchParams(window.location.search);
    const highlightType = urlParams.get('highlight');
    
    if (highlightType === 'beneficiary') {
      const block = urlParams.get('block');
      const lot = urlParams.get('lot');
      const name = urlParams.get('name');
      
      if (block && lot) {
        // Wait for table to be populated before highlighting
        setTimeout(() => {
          highlightBeneficiaryRow(block, lot, name);
        }, 1000);
      }
    } else if (highlightType && highlightType.startsWith('block-') && highlightType.includes('-lot-')) {
      // Handle existing block-lot highlighting format
      const parts = highlightType.split('-');
      const block = parts[1];
      const lot = parts[3];
      
      if (block && lot) {
        setTimeout(() => {
          highlightRow(block, lot);
        }, 1000);
      }
    }
  }

  // Function to highlight beneficiary row by block, lot, and optionally name
  function highlightBeneficiaryRow(block, lot, name = null) {
    residentTable.querySelectorAll('tr').forEach(r => r.classList.remove('highlight'));

    const rows = Array.from(residentTable.querySelectorAll('tr'));
    let matchedRow = null;
    
    // First try to match by block and lot
    const blockLotMatches = rows.filter(row => {
      const rowBlock = row.children[1]?.textContent.trim();
      const rowLot = row.children[2]?.textContent.trim();
      return String(rowBlock) === String(block) && String(rowLot) === String(lot);
    });
    
    if (blockLotMatches.length === 1) {
      // Only one match, use it
      matchedRow = blockLotMatches[0];
    } else if (blockLotMatches.length > 1 && name) {
      // Multiple matches, try to find by name as well
      matchedRow = blockLotMatches.find(row => {
        const rowName = row.children[0]?.textContent.trim();
        return rowName.toLowerCase().includes(name.toLowerCase()) || 
               name.toLowerCase().includes(rowName.toLowerCase());
      });
      
      // If no name match, just use the first block/lot match
      if (!matchedRow) {
        matchedRow = blockLotMatches[0];
      }
    }

    if (matchedRow) {
      matchedRow.classList.add('highlight');
      matchedRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Also highlight in SVG if possible
      const svgGroups = Array.from(container.querySelectorAll('svg g'));
      const matchSvgArea = svgGroups.find(g => {
        const aBlock = parseBlockFromId(g.id);
        const aLot = parseLotFromId(g.id);
        return String(aBlock) === String(block) && String(aLot) === String(lot);
      });

      if (matchSvgArea) {
        highlightSvgArea(matchSvgArea);
      }
      
      console.log(`Highlighted beneficiary: Block ${block}, Lot ${lot}`, name ? `Name: ${name}` : '');
    } else {
      console.log(`No matching row found for Block ${block}, Lot ${lot}`, name ? `Name: ${name}` : '');
    }
  }

  // Initialize the page
  loadAreaData();
  
  // Handle URL highlighting after data loads
  setTimeout(handleUrlHighlighting, 2000);

})();

// Search functionality for residents
function initSearch() {
  console.log('🔍 Initializing search functionality...');
  
  const searchInput = document.getElementById('search-input');
  const clearBtn = document.getElementById('clear-btn');
  const searchResults = document.getElementById('search-results');
  
  console.log('Search elements:', {
    searchInput: !!searchInput,
    clearBtn: !!clearBtn,
    searchResults: !!searchResults
  });
  
  if (!searchInput || !clearBtn || !searchResults) {
    console.error('❌ Search elements not found!');
    return;
  }
  
  let searchTimeout;
  let selectedIndex = -1;
  let currentResults = [];

  function performSearch() {
    const query = searchInput.value.trim().toLowerCase();
    
    if (query.length < 2) {
      searchResults.style.display = 'none';
      currentResults = [];
      selectedIndex = -1;
      clearHighlights();
      return;
    }
    
    // Get current table rows for searching
    const residentTable = document.getElementById('resident-table');
    if (!residentTable) {
      searchResults.innerHTML = '<div class="search-result-item no-results">Table not loaded</div>';
      searchResults.style.display = 'block';
      return;
    }
    
    const rows = Array.from(residentTable.querySelectorAll('tbody tr'));
      const filteredResults = rows.filter(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length < 1) return false;
        const name = cells[0].textContent.toLowerCase();
        // Match words that start with the query
        const words = name.split(/\s+/);
        return words.some(word => word.startsWith(query));
      }).slice(0, 3); // Show maximum 3 results
    
    displaySearchResults(filteredResults, query);
  }

  function displaySearchResults(results, query) {
    if (results.length === 0) {
      searchResults.innerHTML = '<div class="search-result-item no-results">No residents found</div>';
      searchResults.style.display = 'block';
      return;
    }
    
    currentResults = results;
    const resultsHTML = results.map((row, index) => {
      const cells = row.querySelectorAll('td');
      const name = cells[0].textContent;
      const block = cells[1] ? cells[1].textContent : 'N/A';
      const lot = cells[2] ? cells[2].textContent : 'N/A';
      return `<div class="search-result-item" data-index="${index}">${name} (Blk ${block}, Lot ${lot})</div>`;
    }).join('');
    
    searchResults.innerHTML = resultsHTML;
    searchResults.style.display = 'block';
    selectedIndex = -1;
    
    // Add click handlers
    searchResults.querySelectorAll('.search-result-item').forEach((item, index) => {
      item.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        selectResult(index);
      });
    });
  }

  function selectResult(index) {
    if (index >= 0 && index < currentResults.length) {
      const row = currentResults[index];
      const cells = row.querySelectorAll('td');
      const block = cells[1] ? cells[1].textContent : null;
      const lot = cells[2] ? cells[2].textContent : null;
      
      // Clear search UI
      searchInput.value = '';
      searchResults.style.display = 'none';
      
      // Highlight table row (without affecting layout)
      clearHighlights();
      row.classList.add('highlight');
      row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Highlight corresponding SVG area (without affecting layout)
      if (block && lot) {
        highlightSvgByBlockLot(block, lot);
      }
    }
  }

  function highlightSvgByBlockLot(block, lot) {
    const container = document.getElementById('map-container');
    if (!container) return;
    
    // Clear any existing search highlights
    container.querySelectorAll('svg g.search-highlight').forEach(g => {
      g.classList.remove('search-highlight');
    });
    
    const svgGroups = Array.from(container.querySelectorAll('svg g'));
    const matchArea = svgGroups.find(g => {
      const id = g.id || '';
      const aBlock = parseBlockFromId(id);
      const aLot = parseLotFromId(id);
      return String(aBlock) === String(block) && String(aLot) === String(lot);
    });
    
    if (matchArea) {
      matchArea.classList.add('search-highlight');
    }
  }

  function clearHighlights() {
    // Clear table highlights
    const residentTable = document.getElementById('resident-table');
    if (residentTable) {
      residentTable.querySelectorAll('tr').forEach(r => r.classList.remove('highlight'));
    }
    
    // Clear SVG search highlights (preserve original layout)
    const container = document.getElementById('map-container');
    if (container) {
      container.querySelectorAll('svg g.search-highlight').forEach(g => {
        g.classList.remove('search-highlight');
      });
    }
  }

  function clearSearch() {
    searchInput.value = '';
    searchResults.style.display = 'none';
    clearBtn.style.display = 'none';
    clearHighlights();
    searchInput.focus();
  }

  // Show/hide clear button based on input content
  searchInput.addEventListener('input', (e) => {
    const query = e.target.value.trim();
    console.log('🔤 Input event - query:', query, 'length:', query.length);
    
    // Show clear button immediately when there's text
    clearBtn.style.display = query.length > 0 ? 'block' : 'none';
    
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(performSearch, 300);
  });

  clearBtn.addEventListener('click', (e) => {
    e.preventDefault();
    clearSearch();
  });

  // Keyboard navigation
  searchInput.addEventListener('keydown', (e) => {
    const items = searchResults.querySelectorAll('.search-result-item:not(.no-results)');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
      updateSelection();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = Math.max(selectedIndex - 1, -1);
      updateSelection();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0) {
        selectResult(selectedIndex);
      }
    } else if (e.key === 'Escape') {
      clearSearch();
    }
  });

  function updateSelection() {
    const items = searchResults.querySelectorAll('.search-result-item:not(.no-results)');
    items.forEach((item, index) => {
      item.classList.toggle('selected', index === selectedIndex);
    });
  }
  
  // Hide results when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.search-bar')) {
      searchResults.style.display = 'none';
    }
  });

  // Show clear button on focus if there's text
  searchInput.addEventListener('focus', () => {
    if (searchInput.value.trim().length > 0) {
      clearBtn.style.display = 'block';
    }
  });
}

// Parse block and lot functions (moved outside for search access)
function parseBlockFromId(id) {
  if (!id) return null;
  const patterns = [
    /[Bb](\d+)/,
    /Block[\s_-]*(\d+)/i,
    /blk[\s_-]*(\d+)/i,
    /b[\s_-]*(\d+)/i
  ];
  
  for (const pattern of patterns) {
    const match = id.match(pattern);
    if (match) return parseInt(match[1]);
  }
  return null;
}

function parseLotFromId(id) {
  if (!id) return null;
  const patterns = [
    /[Ll](\d+)/,
    /Lot[\s_-]*(\d+)/i,
    /lot[\s_-]*(\d+)/i,
    /l[\s_-]*(\d+)/i
  ];
  
  for (const pattern of patterns) {
    const match = id.match(pattern);
    if (match) return parseInt(match[1]);
  }
  return null;
}

// Back arrow functionality - go back to where user came from
function goBack() {
  // Check if there's a previous page in history
  if (window.history.length > 1) {
    window.history.back();
  } else {
    // Fallback to map index if no history
    window.location.href = '/admin/map/index.html';
  }
}

// Initialize search when page loads
document.addEventListener('DOMContentLoaded', function() {
  // Wait longer for all data to load before initializing search
  setTimeout(() => {
    console.log('Initializing search functionality...');
    initSearch();
  }, 2500);
});
</script>

<style>
/* Dynamic legend colors based on blocks count */
.legend-color {
  width: 16px;
  height: 16px;
  border-radius: 4px;
  display: inline-block;
  border: 1px solid rgba(0,0,0,0.06);
  flex: 0 0 16px;
  margin-right: 8px;
}

/* Filter dropdown styles */
.filter-btn {
  background: #4285f4;
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 8px;
  transition: background-color 0.2s ease;
}

.filter-btn:hover {
  background: #3367d6;
}

.filter-menu {
  position: absolute;
  background: white;
  border: 1px solid #ddd;
  border-radius: 5px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  z-index: 1000;
  min-width: 150px;
  max-height: 200px;
  overflow-y: auto;
  margin: 0;
  padding: 5px 0;
  top: 100%;
  left: 0;
  list-style: none;
}

.filter-menu li {
  padding: 8px 12px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  font-size: 14px;
}

.filter-menu li:hover {
  background-color: #3367d6;
}

.filter-menu[hidden] {
  display: none !important;
}

/* Table styling with fixed header */
.list-table {
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  background: white;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  height: 400px;
}

.table-header {
  flex-shrink: 0;
  background: #f5f6fa;
  border-bottom: 2px solid #ddd;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  z-index: 100;
}

.table-header table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  table-layout: fixed;
}

.table-body {
  flex: 1;
  overflow-y: auto;
  background: white;
}

.table-body table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  table-layout: fixed;
}

.list-table th:nth-child(1), .list-table td:nth-child(1) { width: 40%; } /* Name */
.list-table th:nth-child(2), .list-table td:nth-child(2) { width: 20%; } /* Block */
.list-table th:nth-child(3), .list-table td:nth-child(3) { width: 20%; } /* Lot No. */
.list-table th:nth-child(4), .list-table td:nth-child(4) { width: 20%; } /* Area */

.list-table th {
  padding: 12px 15px;
  text-align: center;
  background: #f5f6fa;
  font-weight: 600;
  color: #333;
  border-right: 1px solid #ddd;
  position: relative;
}

.list-table th:last-child {
  border-right: none;
}

.list-table td {
  padding: 12px 15px;
  border-bottom: 1px solid #eee;
  transition: background-color 0.2s ease;
  text-align: center;
}

.list-table tr:hover td {
  background-color: #f9f9f9;
}

.list-table tr.highlight td {
  background-color: #e3f2fd !important;
  border-left: 3px solid #2196f3;
}

.list-table tr.generated-lot-row td {
  background-color: #f8f9fa;
  font-style: italic;
  color: #6c757d;
}

.list-table tr.generated-lot-row:hover td {
  background-color: #e9ecef;
}

/* Stats section styling - matching sjc.html */
.stats-section {
  display: flex;
  gap: 15px;
  margin-top: 20px;
  justify-content: space-between;
}

.stat-card {
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
}

.stat-card i {
  font-size: 24px;
  color: #4285f4;
}

.stat-card div h3 {
  margin: 0;
  font-size: 20px;
  color: #333;
}

.stat-card div p {
  margin: 0;
  color: #666;
  font-size: 12px;
}

/* Tooltip styling */
.tooltip {
  position: absolute;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  z-index: 1000;
  pointer-events: none;
  display: none;
  max-width: 200px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.tooltip-content {
  line-height: 1.4;
}

/* SVG interaction styles */
svg g:hover {
  cursor: pointer;
}

svg g.selected-area path,
svg g.selected-area rect,
svg g.selected-area polygon,
svg g.selected-area circle {
  stroke: #2196f3 !important;
  stroke-width: 2 !important;
  filter: brightness(1.1);
}

/* Separate highlighting style for search results */
svg g.search-highlight path,
svg g.search-highlight rect,
svg g.search-highlight polygon,
svg g.search-highlight circle {
  stroke: #ff9800 !important;
  stroke-width: 3 !important;
  filter: brightness(1.3) saturate(1.2);
  stroke-dasharray: 5,5;
  animation: search-pulse 2s infinite;
}

@keyframes search-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Loading states */
.loading {
  color: #999;
  font-style: italic;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  .content-wrapper {
    flex-direction: column;
    height: auto;
  }
  
  .map-section {
    height: 400px;
    flex: none;
  }
  
  .info-panel {
    max-width: none;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 15px;
  }
  
  .president-info,
  .complaint-stats {
    flex: 1;
    min-width: 250px;
  }
  
  .beneficiaries-section {
    flex: 100%;
    min-height: 300px;
  }
}

@media (max-width: 768px) {
  .content-wrapper {
    padding: 10px;
    gap: 15px;
  }
  
  .info-panel {
    flex-direction: column;
  }
  
  .stats-grid {
    gap: 10px;
  }
  
  .stat-number {
    font-size: 20px;
  }
}
</style>
</body>
</html>
