<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/complainants.css">
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/staff/complaints/assigned" class="nav-item active">Complaints</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <header class="header">
      <div class="header-content">
        <div class="header-left">
          <button class="back-arrow" onclick="goBack()" title="Back to Complaints">‚Üê</button>
          <h1>Complaint</h1>
        </div>
      </div>
    </header>

    <div class="complaint-layout" style="margin-top: 30px;">
      <div class="complaint-form">Complaint form data will load here...</div>

      <!-- Right Panel -->
      <div class="right-panel">
        <div class="map-card">Map / Asset details here...</div>

        <!-- Dynamic Timeline Component for Staff (copied from admin layout) -->
        <!-- TODO BACKEND: Replace static timeline entries with timeline data from DB -->
        <div class="timeline" id="complaintTimeline">
          <div class="timeline-loading" id="timelineLoading" style="text-align: center; padding: 20px; color: #666;">
            Loading timeline...
          </div>
        </div>
        <button class="update-btn" onclick="openComplaint()">Update Status</button>
      </div>
    </div>

    <!-- MODAL -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <!-- HEADER -->
    <div class="modal-top">
      <div class="left-content">
        <strong>Assigned To: Maybelen Jamorawon</strong>
        <h2 class="modal-title">Inspection</h2>
      </div>
      <div id="datetime">
        <div id="date">21/10/2025</div>
        <div id="time">9:00 AM</div>
      </div>
    </div>

    <div class="modal-body">
      <!-- Dynamic data loaded from admin's invitation assignment -->
      <div class="form-group">
        <label>Individuals to be informed:</label>
        <div class="stacked-inputs" id="staffInvIndividuals">
          <input type="text" value="Loading..." readonly />
        </div>
      </div>
      <hr>

      <div class="form-group">
        <label>Date:</label>
        <input type="text" id="staffInvDate" value="Loading..." class="short" readonly />
      </div>

      <div class="form-group">
        <label>Time:</label>
        <input type="text" id="staffInvTime" value="Loading..." class="short" readonly />
      </div>

      <div class="form-group">
        <label>Venue</label>
        <input type="text" id="staffInvVenue" value="Loading..." class="short" readonly />
      </div>

      <div class="form-group">
        <label>Agenda</label>
        <input type="text" id="staffInvAgenda" value="Loading..." class="short" readonly />
      </div>

      <hr>

      <div class="form-group">
        <label id="long">Attach the Notice of Meeting:</label>
        <div class="file-upload">
          <input type="file" id="inspectionFile" accept=".pdf,.jpg,.jpeg" multiple hidden />
          <button type="button" onclick="document.getElementById('inspectionFile').click()" style="align-items: flex-start;">Upload</button>
        </div>
      </div>

      <div class="form-group">
        <label id="short">Attached Files:</label>
        <div id="inspectionFilesList" class="attached-files"></div>
      </div>
    </div>

    <!-- FOOTER -->
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeComplaint()">Cancel</button>
      <button class="btn-save" onclick="resolveTask()">Update</button>
    </div>
  </div>
</div>
  </main>

  <script>
(function () {
  const modal = document.getElementById('modal');
  const dateEl = document.getElementById('datetime');
  const fileInput = document.getElementById("inspectionFile");
  const previewSection = document.getElementById("inspectionFilesPreview");
  const filesList = document.getElementById("inspectionFilesList");
  let interval = null;

  // Update date & time inside Action modal
  function updateComplaintDateTime() {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    dateEl.innerHTML = `${dateStr}<br>${timeStr}`;
  }

  // Load invitation data from database using staff-specific endpoint
  async function loadInvitationData() {
    try {
      const complaintId = getComplaintIdFromURL();
      if (!complaintId) {
        console.error('No complaint ID found for loading invitation data');
        return;
      }

      console.log(`[STAFF DATA] Loading invitation data for complaint ${complaintId}`);
      
      // Fetch the actual invitation details that admin inputted when creating the Invitation action
      const response = await fetch(`/admin/complaints/api/staff_invitation_data/${complaintId}`, {
        credentials: 'same-origin'
      });

      if (!response.ok) {
        console.error(`Failed to load invitation data: ${response.status}`);
        // Set fallback values if API fails
        const individualsContainer = document.getElementById('staffInvIndividuals');
        const dateEl = document.getElementById('staffInvDate');
        const timeEl = document.getElementById('staffInvTime');
        const venueEl = document.getElementById('staffInvVenue');
        const agendaEl = document.getElementById('staffInvAgenda');
        
        if (individualsContainer) individualsContainer.innerHTML = '<input type="text" value="Not assigned yet" readonly />';
        if (dateEl) dateEl.value = 'Not set';
        if (timeEl) timeEl.value = 'Not set';
        if (venueEl) venueEl.value = 'Not specified';
        if (agendaEl) agendaEl.value = 'Not specified';
        return;
      }

      const result = await response.json();
      console.log('[STAFF DATA] Admin invitation data received:', result);
      
      // Extract the invitation details (already processed by backend)
      const individuals = result.individuals;
      const meetingDate = result.meeting_date;
      const meetingTime = result.meeting_time;
      const venue = result.venue;
      const agenda = result.agenda;
      
      // Fill readonly fields with data from admin's invitation action
      const individualsContainer = document.getElementById('staffInvIndividuals');
      const dateEl = document.getElementById('staffInvDate');
      const timeEl = document.getElementById('staffInvTime');
      const venueEl = document.getElementById('staffInvVenue');
      const agendaEl = document.getElementById('staffInvAgenda');
      
      // Handle individuals to invite (already split by backend)
      if (individualsContainer && individuals) {
        const individualsList = Array.isArray(individuals) ? individuals : [individuals];
        individualsContainer.innerHTML = individualsList.map(person => 
          `<input type="text" value="${person}" readonly />`
        ).join('');
      } else if (individualsContainer) {
        individualsContainer.innerHTML = '<input type="text" value="Not specified" readonly />';
      }
      
      if (dateEl) dateEl.value = meetingDate || 'Not specified';
      if (timeEl) timeEl.value = meetingTime || 'Not specified';
      if (venueEl) venueEl.value = venue || 'Not specified';
      if (agendaEl) agendaEl.value = agenda || 'Not specified';
      
    } catch (error) {
      console.error('[STAFF DATA] Error loading admin invitation action details:', error);
      // Set error values
      const individualsContainer = document.getElementById('staffInvIndividuals');
      const dateEl = document.getElementById('staffInvDate');
      const timeEl = document.getElementById('staffInvTime');
      const venueEl = document.getElementById('staffInvVenue');
      const agendaEl = document.getElementById('staffInvAgenda');
      
      if (individualsContainer) individualsContainer.innerHTML = '<input type="text" value="Error loading admin data" readonly />';
      if (dateEl) dateEl.value = 'Error loading data';
      if (timeEl) timeEl.value = 'Error loading data';
      if (venueEl) venueEl.value = 'Error loading data';
      if (agendaEl) agendaEl.value = 'Error loading data';
    }
  }

  // Check if page is in readonly mode (resolved complaints)
  function isReadonlyMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('readonly') === 'true';
  }

  // Open Action modal directly and load invitation data
  function openComplaint() {
    // Check if in readonly mode
    if (isReadonlyMode()) {
      alert('This complaint has been resolved and cannot be modified.');
      return;
    }
    
    modal.style.display = 'flex';
    updateComplaintDateTime();
    if (!interval) interval = setInterval(updateComplaintDateTime, 1000);
    
    // Load invitation assignment data from database
    loadInvitationData();
  }

// Apply readonly styles and disable functionality for resolved complaints
function applyReadonlyState() {
  if (isReadonlyMode()) {
    // Gray out and disable the Action button
    const actionBtn = document.querySelector('.action-btn');
    if (actionBtn) {
      actionBtn.style.opacity = '0.5';
      actionBtn.style.cursor = 'not-allowed';
      actionBtn.style.backgroundColor = '#6c757d';
      actionBtn.title = 'This complaint has been resolved';
    }
    
    // Disable all form fields in the modal
    const modal = document.getElementById('modal');
    if (modal) {
      const formElements = modal.querySelectorAll('input, textarea, select, button');
      formElements.forEach(element => {
        if (element.type !== 'button' || element.textContent === 'Update') {
          element.disabled = true;
          element.style.opacity = '0.6';
          element.style.cursor = 'not-allowed';
        }
      });
    }
    
    // Add visual indicator
    const header = document.querySelector('.header h1');
    if (header) {
      header.innerHTML += ' <span style="color: #6c757d; font-size: 0.8em;">(Resolved - Read Only)</span>';
    }
  }
}

  function closeComplaint() {
    modal.style.display = 'none';
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  }

  modal.addEventListener('click', e => {
    if (e.target === modal) closeComplaint();
  });

  window.openComplaint = openComplaint;
  window.closeComplaint = closeComplaint;
  window.updateComplaintDateTime = updateComplaintDateTime;

  // File upload preview
if (fileInput) {
  fileInput.addEventListener("change", function () {
    filesList.innerHTML = "";
    const files = Array.from(this.files);

    if (files.length > 0) {
      filesList.style.display = "block"; // show list only if files uploaded
      files.forEach(file => {
        const fileRow = document.createElement("div");
        fileRow.className = "file-item";
        fileRow.textContent = file.name;
        filesList.appendChild(fileRow);
      });
    } else {
      filesList.style.display = "none"; // hide if no files
    }
  });
}
})();

/* Files Modal - Removed because filesModal element doesn't exist in HTML */
// These functions were causing TypeError: Cannot read properties of null
// Commented out until filesModal is added to HTML structure

/*
function openFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "flex";
    updateFilesDateTime();
  }
}

function closeFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "none";
  }
}

function updateFilesDateTime() {
  const filesDateTime = document.getElementById("filesDateTime");
  if (filesDateTime) {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    filesDateTime.innerHTML = `${dateStr}<br>${timeStr}`;
  }
}

const filesModal = document.getElementById("filesModal");
if (filesModal) {
  filesModal.addEventListener("click", e => {
    if (e.target.id === "filesModal") closeFiles();
  });
}
*/

/* Switch tabs - Removed because .file-tabs elements don't exist in HTML */
// These selectors were causing potential errors
// Commented out until file-tabs are added to HTML structure

/*
document.querySelectorAll('.file-tabs .tab').forEach(tab => {
  tab.addEventListener('click', function () {
    document.querySelectorAll('.file-tabs .tab').forEach(t => t.classList.remove('active'));
    this.classList.add('active');

    const target = this.getAttribute('data-tab');
    const uploadedList = document.querySelector('.uploaded-list');
    const downloadableList = document.querySelector('.downloadable-list');
    
    if (uploadedList) uploadedList.style.display = target === "uploaded" ? "block" : "none";
    if (downloadableList) downloadableList.style.display = target === "downloadable" ? "block" : "none";
  });
});
*/

/* Save Button - you don‚Äôt have .btn-save in HTML, so I commented this out
const saveBtn = document.querySelector(".btn-save");
if (saveBtn) {
  saveBtn.addEventListener("click", () => {
    const findings = document.getElementById("findings").value.trim();
    const files = Array.from(document.getElementById("inspectionFile").files);
    if (!findings) {
      alert("Inspection Findings are required.");
      return;
    }
    if (files.length === 0) {
      alert("Please attach at least one supporting document.");
      return;
    }

    const payload = {
      assigned_to: "Alberto Nonato Jr.", // Placeholder
      deadline: "29/10/2025",
      lot: "Alley 2 Sta. Catalina, Block 1, Lot 2",
      scope: "Affected lot/s, Measurement of lot/s",
      findings,
      files: files.map(f => f.name)
    };
    console.log("Submitting inspection data:", payload);
    closeComplaint();
  });
}
*/

// Resolved Task function - implements Staff workflow for invitation completion
// When staff clicks Update: last timeline status changes to "Sent Invitation"
// Complaint then transitions to appear under resolved.html for staff view
async function resolveTask() {
  const files = Array.from(document.getElementById("inspectionFile").files);

  // Validation checks
  if (!findings && files.length === 0) {
    alert("Please input inspection findings and attach the supporting documents/evidence first.");
    return;
  }
  if (!findings) {
    alert("Please input inspection findings first.");
    return;
  }
  if (files.length === 0) {
    alert("Please attach the supporting documents or evidence of the inspection first.");
    return;
  }

  // If validation passes ‚Üí proceed with Sent Invitation workflow
  const complaintId = getComplaintIdFromURL();
  
  try {
    console.log('[STAFF WORKFLOW] Submitting Sent Invitation for complaint:', complaintId);
    
    const response = await fetch('/admin/complaints/api/staff_complete_task', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        complaint_id: complaintId,
        action_type: 'Sent Invitation',
        description: 'Notice of Meeting sent to all parties',
        files: files.map(f => f.name),
        staff_account_type: currentStaffAccount, // admin.account == 2
        completed_by_staff: true, // Flag to mark this as staff completion
        task_type: 'invitation', // Specify this is invitation completion
        invitation_details: {
          notice_attached: true,
          file_count: files.length,
          completion_notes: 'Meeting notice distributed to all specified individuals'
        }
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // Update timeline to show "Sent Invitation" status
      await refreshTimeline();
      
      // Update resolved counter
      updateResolvedCounter();
      
      // Redirect to staff resolved view (complaint should now appear there)
      window.location.href = '/staff/complaints/resolved';
    } else {
      console.error('Error completing invitation task:', result.error || result.message);
    }
    
  } catch (error) {
    console.error('[STAFF WORKFLOW] Error completing invitation task:', error);
  } finally {
    // Close modal after submission
    closeComplaint();
  }
}

function getComplaintIdFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const id = urlParams.get('id');
  console.log('URL parameters:', window.location.search);
  console.log('Extracted complaint ID:', id);
  return id || '1';
}

// Back button functionality
function goBack() {
  const urlParams = new URLSearchParams(window.location.search);
  const referrer = urlParams.get('referrer');
  
  if (referrer) {
    window.location.href = `/staff/complaints/${referrer}`;
  } else {
    window.location.href = '/staff/complaints/assigned';
  }
}

// Update resolved counter function
function updateResolvedCounter() {
  // Call parent window to refresh stats if available
  if (window.opener && !window.opener.closed) {
    try {
      window.opener.loadStats();
    } catch (e) {
      console.log('Could not update parent stats:', e);
    }
  }
  
  // Also try to update local counter if element exists
  const resolvedElement = document.getElementById('resolved-count');
  if (resolvedElement) {
    const currentCount = parseInt(resolvedElement.textContent) || 0;
    resolvedElement.textContent = currentCount + 1;
  }
}

// Make functions globally available
window.goBack = goBack;
window.updateResolvedCounter = updateResolvedCounter;

// =====================================
// DYNAMIC TIMELINE SYSTEM FOR STAFF
// =====================================

// Timeline management for Staff View
let timelineData = [];
let currentRole = 'staff'; // Staff role for this page
let currentStaffAccount = 2; // Staff account type (admin.account == 2)

// Load real timeline data from API for staff view
// Shows: previously saved status entries from admin up to staff's assigned task
async function loadTimelineData() {
  try {
    const complaintId = getComplaintIdFromURL();
    if (!complaintId) {
      console.error('[STAFF TIMELINE] No complaint ID found in URL');
      return [];
    }
    
    console.log(`[STAFF TIMELINE] Loading timeline for complaint ${complaintId} with staff role`);
    
    const response = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=staff&account_type=2`, {
      credentials: 'same-origin'
    });
    
    console.log(`[STAFF TIMELINE] API response status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[STAFF TIMELINE] API error: ${response.status} - ${errorText.substring(0, 200)}`);
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('[STAFF TIMELINE] Real timeline data received:', data);
    
    return data.timeline || [];
  } catch (error) {
    console.error('[STAFF TIMELINE] Error loading timeline data:', error);
    return [];
  }
}

// Format date for timeline display
function formatTimelineDate(dateString) {
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'numeric',
      day: 'numeric',
      year: 'numeric'
    });
  } catch (error) {
    return dateString;
  }
}

// Truncate description to one line with ellipsis
function truncateDescription(text, maxLength = 80) {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

// Map action types to standardized timeline status labels - ONLY 7 ALLOWED STATUSES
function mapActionToTimelineStatus(actionType, isCompleted = false, role = 'staff') {
  // STAFF VIEW: Only allowed sequential flow statuses
  const statusMap = {
    'Submitted': 'Submitted a Valid Complaint',
    'Inspection': isCompleted ? 'Inspection done' : 'Inspection',
    'Invitation': isCompleted ? 'Sent Invitation' : 'Send Invitation',
    'Task Completed': 'Task Completed',
    'Resolved': 'Resolved'
  };
  return statusMap[actionType] || actionType;
}

// Generate default messages for actions without descriptions - ONLY 7 ALLOWED STATUSES
function getDefaultMessage(actionType, assignedTo) {
  const timelineStatus = mapActionToTimelineStatus(actionType);
  const messages = {
    'Submitted a Valid Complaint': 'Your complaint has been received and validated',
    'Inspection': `Site inspection assigned to ${assignedTo || 'inspector'}`,
    'Inspection done': `Site inspection completed by ${assignedTo || 'inspector'}`,
    'Send Invitation': `Invitation task assigned to ${assignedTo || 'staff'}`,
    'Sent Invitation': `Invitation sent to involved parties by ${assignedTo || 'staff'}`,
    'Task Completed': `Task completed and passed back to admin`,
    'Resolved': 'Complaint has been resolved'
  };
  return messages[timelineStatus] || `${timelineStatus} completed`;
}

// Filter timeline entries based on user role
function filterEntriesByRole(entries, role) {
  switch (role) {
    case 'admin':
      // Admin sees all entries
      return entries;
      
    case 'staff':
      // Staff sees previously saved status entries from admin up to their assigned task
      // Show ALL entries from admin work PLUS any staff completed tasks
      console.log('[STAFF FILTER] Original entries:', entries);
      const filteredForStaff = entries.filter(entry => {
        // Show all admin entries (account type 1) and staff completed entries
        return entry.admin_account_type === 1 || entry.completed_by_staff === true;
      }).map(entry => {
        // If this is the staff's completed task, show "Task Completed"
        if (entry.completed_by_staff) {
          return {
            ...entry,
            type_of_action: 'Task Completed',
            description: 'Task completed and passed back to admin for further processing'
          };
        }
        return entry;
      });
      console.log('[STAFF FILTER] Filtered entries for staff:', filteredForStaff);
      return filteredForStaff;
      
    case 'complainant':
      // Complainant sees only milestone completions
      const milestones = ['Inspection done', 'Sent Invitation', 'Assessment', 'Resolved'];
      return entries.filter(entry => {
        const status = mapActionToTimelineStatus(entry.type_of_action);
        return milestones.includes(status) || entry.type_of_action === 'Submitted';
      }).map(entry => {
        // Simplify for complainant view
        if (entry.type_of_action === 'Submitted') {
          return {
            ...entry,
            type_of_action: 'Submitted a valid complaint',
            description: 'Your complaint has been received and validated'
          };
        }
        return entry;
      });
      
    default:
      return entries;
  }
}

// Render timeline entries for staff view (real data only)
function renderTimeline(entries) {
  console.log('[STAFF TIMELINE] renderTimeline called with entries:', entries);
  
  const timelineContainer = document.getElementById('complaintTimeline');
  const loadingElement = document.getElementById('timelineLoading');
  
  if (!timelineContainer) {
    console.error('[STAFF TIMELINE] Timeline container not found!');
    return;
  }
  
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  if (!entries || entries.length === 0) {
    console.log('[STAFF TIMELINE] No timeline entries found from database');
    timelineContainer.innerHTML = `
      <div class="timeline-empty" style="text-align: center; padding: 20px; color: #666;">
        <h4>Timeline Status</h4>
        <p>No timeline entries available for this complaint.</p>
        <p><small>Timeline will show once admin assigns tasks and you begin work.</small></p>
      </div>`;
    return;
  }
  
  console.log(`[STAFF TIMELINE] Rendering ${entries.length} real timeline entries`);
  
  // Filter entries for staff view: previously saved status entries from admin up to staff's assigned task
  let filteredEntries = filterEntriesByRole(entries, 'staff');
  
  // Sort entries by date (most recent first)
  filteredEntries.sort((a, b) => new Date(b.action_datetime) - new Date(a.action_datetime));
  
    // Generate HTML for timeline entries (copy admin design structure)
    const timelineHTML = filteredEntries.map(entry => {
      const timelineStatus = mapActionToTimelineStatus(entry.type_of_action, false, 'staff');
      const date = formatTimelineDate(entry.action_datetime);
      const description = entry.description ? 
        truncateDescription(entry.description) : 
        getDefaultMessage(entry.type_of_action, entry.assigned_to);
      
      // File download button for files uploaded by staff/admin 
      const fileButton = entry.has_file ? 
        `<button class="file-btn" data-pdf="${entry.file_path || '#'}" onclick="openTimelineFile('${entry.file_path || '#'}')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 10px;">üìÑ Download File</button>` : 
        '';
      
      const assignedTo = entry.assigned_to ? `<span>${entry.assigned_to}</span>` : '';
      
      return `
        <div class="timeline-entry" data-status="${timelineStatus.toLowerCase().replace(/\s+/g, '-')}">
          <h4>${date} - ${timelineStatus} 
            ${fileButton}
            ${assignedTo}
          </h4>
          <p>${description}</p>
        </div>
      `;
    }).join('');  timelineContainer.innerHTML = timelineHTML;
  
  // Re-attach file button event listeners
  attachFileButtonListeners();
}

// Re-attach event listeners to file buttons
function attachFileButtonListeners() {
  document.querySelectorAll('.file-btn').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const pdfPath = this.getAttribute('data-pdf');
      if (pdfPath && pdfPath !== '#') {
        openTimelineFile(pdfPath);
      }
    });
  });
}

// Open timeline file
function openTimelineFile(filePath) {
  if (filePath && filePath !== '#') {
    window.open(filePath, '_blank');
  } else {
    alert('No file available for this entry.');
  }
}

// Refresh timeline data
async function refreshTimeline() {
  console.log('[TIMELINE DEBUG] refreshTimeline() called');
  
  try {
    const loadingElement = document.getElementById('timelineLoading');
    if (loadingElement) {
      loadingElement.style.display = 'block';
      loadingElement.textContent = 'Loading timeline...';
      console.log('[TIMELINE DEBUG] Showing loading element');
    }
    
    console.log('[TIMELINE DEBUG] Starting timeline refresh...');
    const entries = await loadTimelineData();
    console.log('[TIMELINE DEBUG] Timeline entries loaded:', entries);
    
    if (!entries) {
      console.error('[TIMELINE DEBUG] loadTimelineData returned null/undefined');
      throw new Error('Failed to load timeline data');
    }
    
    timelineData = entries;
    console.log(`[TIMELINE DEBUG] About to render ${entries.length} entries`);
    renderTimeline(entries);
    console.log('[TIMELINE DEBUG] Timeline refresh completed successfully');
    
  } catch (error) {
    console.error('[TIMELINE DEBUG] Error refreshing timeline:', error);
    const timelineContainer = document.getElementById('complaintTimeline');
    if (timelineContainer) {
      timelineContainer.innerHTML = `
        <div class="timeline-error" style="text-align: center; padding: 20px; color: #d32f2f; border: 2px solid #f44336; border-radius: 8px; background: #ffebee;">
          <h4>Timeline Loading Error</h4>
          <p>Error: ${error.message}</p>
          <p><small>Check browser console for details.</small></p>
          <button onclick="refreshTimeline()" style="margin-top: 10px; padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry</button>
        </div>`;
    }
  }
}

// Removed showFallbackTimeline - staff view uses real database data only

// Initialize timeline on page load - load real data only
document.addEventListener('DOMContentLoaded', function() {
  console.log('[STAFF TIMELINE] Page loaded, loading real timeline data from database');
  
  // Load real timeline data immediately (no sample data)
  refreshTimeline();
  
  // Apply readonly state if needed
  applyReadonlyState();
});

// Make timeline functions globally available
window.refreshTimeline = refreshTimeline;
</script>

</body>
</html>
