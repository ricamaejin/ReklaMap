<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/complainants.css">
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/staff/complaints/assigned" class="nav-item active">Complaints</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <header class="header">
      <div class="header-content">
        <div class="header-left">
          <button class="back-arrow" onclick="goBack()" title="Back to Complaints">‚Üê</button>
          <h1>Complaint</h1>
        </div>
      </div>
    </header>

    <div class="complaint-layout" style="margin-top: 30px;">
      <div class="complaint-form">Complaint form data will load here...</div>

      <!-- Right Panel -->
      <div class="right-panel">
        <!-- Dynamic Area Map for Complaint Details -->
        <div class="map-card" id="mapCard">
          <div class="map-loading" id="mapLoading" style="text-align: center; padding: 40px; color: #666;">
            <i class="bi bi-geo-alt-fill" style="font-size: 2em; margin-bottom: 10px;"></i><br>
            Loading area map...
          </div>
          <div class="map-content" id="mapContent" style="display: none;"></div>
          <div class="map-error" id="mapError" style="display: none; text-align: center; padding: 40px; color: #999;">
            <i class="bi bi-exclamation-triangle" style="font-size: 2em; margin-bottom: 10px;"></i><br>
            <span>Area map not available</span>
          </div>
        </div>

        <!-- Dynamic Timeline Component for Staff (copied from admin layout) -->
        <!-- TODO BACKEND: Replace static timeline entries with timeline data from DB -->
        <div class="timeline" id="complaintTimeline">
          <div class="timeline-loading" id="timelineLoading" style="text-align: center; padding: 20px; color: #666;">
            Loading timeline...
          </div>
        </div>
        <button class="update-btn" onclick="openComplaint()" id="updateStatusBtn">Update Status</button>
      </div>
    </div>

    <!-- MODAL -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <!-- HEADER -->
    <div class="modal-top">
      <div class="left-content">
        <strong>Assigned To: Alberto Nonato Jr.</strong>
        <h2 class="modal-title">Inspection</h2>
      </div>
      <div id="datetime">
        <div id="date">21/10/2025</div>
        <div id="time">9:00 AM</div>
      </div>
    </div>

    <!-- FORM BODY -->
    <div class="modal-body">
      <div class="form-group">
        <label>Deadline:</label>
        <input type="text" id="staffDeadline" value="Loading..." readonly />
      </div>

      <div class="form-group">
        <label>Lot to Inspect</label>
        <input type="text" id="staffLocation" value="Loading..." readonly />
      </div>

      <div class="form-group">
        <label>Scope of Inspection:</label>
        <input type="text" id="staffScope" value="Loading..." readonly />
      </div>

      <hr>

      <div class="form-group">
        <label for="findings">Inspection Findings:</label>
        <textarea id="findings" placeholder="Enter inspection findings..."></textarea>
      </div>

      <div class="form-group">
        <label id="long">Attach Supporting Documents or Evidence for the Inspection:</label>
        <div class="file-upload">
          <input type="file" id="inspectionFile" accept=".pdf,.jpg,.jpeg" multiple hidden />
          <button type="button" onclick="document.getElementById('inspectionFile').click()" style="align-items: flex-start;">Upload</button>
        </div>
      </div>

      <div class="form-group">
        <label style="flex: 0 0 165px;">Attached Files:</label>
        <div id="inspectionFilesList" class="attached-files"></div>
      </div>
    </div>

    <!-- FOOTER -->
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeComplaint()">Cancel</button>
      <button class="btn-save" onclick="resolveTask()">Update</button>
    </div>
  </div>
</div>

<!-- Custom Alert Modal (separate overlay) -->
<div class="modal-overlay" id="alertModal" style="display: none;">
  <div class="warning-modal">
    <div class="warning-header">‚ö†Ô∏è WARNING MESSAGE</div>
    <div class="warning-body">
      <div class="warning-text">
        <p id="alertMessage"></p>
      </div>
    </div>
    <div class="warning-footer">
      <button onclick="closeCustomAlert()">OK</button>
    </div>
  </div>
</div>
  </main>

  <script>
(function () {
  const modal = document.getElementById('modal');
  const dateEl = document.getElementById('datetime');
  const fileInput = document.getElementById("inspectionFile");
  const previewSection = document.getElementById("inspectionFilesPreview");
  const filesList = document.getElementById("inspectionFilesList");
  let interval = null;

  // Update date & time inside Action modal
  function updateComplaintDateTime() {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    dateEl.innerHTML = `${dateStr}<br>${timeStr}`;
  }

  // Load inspection data from database using admin's autofill system
  async function loadInspectionData() {
    try {
      const complaintId = getComplaintIdFromURL();
      if (!complaintId) {
        console.error('No complaint ID found for loading inspection data');
        return;
      }

      console.log(`[STAFF DATA] Loading inspection data for complaint ${complaintId}`);
      
      // Use existing admin autofill endpoint but filter for inspection data
      const response = await fetch(`/admin/complaints/api/staff_inspection_data/${complaintId}`, {
        credentials: 'same-origin'
      });

      if (!response.ok) {
        console.error(`Failed to load inspection data: ${response.status}`);
        // Set fallback values if API fails
        document.getElementById('staffDeadline').value = 'Not assigned yet';
        document.getElementById('staffLocation').value = 'Not assigned yet';
        document.getElementById('staffScope').value = 'Not assigned yet';
        return;
      }

      const result = await response.json();
      console.log('[STAFF DATA] Inspection data received:', result);
      
      // The API returns flattened data for easier access
      const data = result.success ? result : result;
      
      // Fill readonly fields with data from admin assignment
      const deadlineEl = document.getElementById('staffDeadline');
      const locationEl = document.getElementById('staffLocation');
      const scopeEl = document.getElementById('staffScope');
      
      if (deadlineEl) {
        deadlineEl.value = data.deadline || 'No deadline set';
      }
      
      if (locationEl) {
        locationEl.value = data.location || 'No location specified';
      }
      
      if (scopeEl) {
        // Convert scope array to readable text
        if (data.scope && Array.isArray(data.scope) && data.scope.length > 0) {
          scopeEl.value = data.scope.join(', ');
        } else if (data.scope && typeof data.scope === 'string') {
          scopeEl.value = data.scope;
        } else {
          scopeEl.value = 'No scope specified';
        }
      }
      
    } catch (error) {
      console.error('[STAFF DATA] Error loading inspection data:', error);
      // Set error values
      document.getElementById('staffDeadline').value = 'Error loading data';
      document.getElementById('staffLocation').value = 'Error loading data';
      document.getElementById('staffScope').value = 'Error loading data';
    }
  }

  // Check if page is in readonly mode (resolved complaints)
  function isReadonlyMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('readonly') === 'true';
  }

  // Open Action modal directly and load inspection data
  function openComplaint() {
    // Check if in readonly mode
    if (isReadonlyMode()) {
      alert('This complaint has been resolved and cannot be modified.');
      return;
    }
    
    modal.style.display = 'flex';
    updateComplaintDateTime();
    if (!interval) interval = setInterval(updateComplaintDateTime, 1000);
    
    // Load inspection assignment data from database
    loadInspectionData();
  }

  function closeComplaint() {
    modal.style.display = 'none';
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  }

  modal.addEventListener('click', e => {
    if (e.target === modal) closeComplaint();
  });

  window.openComplaint = openComplaint;
  window.closeComplaint = closeComplaint;
  window.updateComplaintDateTime = updateComplaintDateTime;

  // Removed duplicate function - using the one above that works with proper element IDs

  // File upload preview
if (fileInput) {
  fileInput.addEventListener("change", function () {
    filesList.innerHTML = "";
    const files = Array.from(this.files);

    if (files.length > 0) {
      filesList.style.display = "block"; // show list only if files uploaded
      files.forEach(file => {
        const fileRow = document.createElement("div");
        fileRow.className = "file-item";
        fileRow.textContent = file.name;
        filesList.appendChild(fileRow);
      });
    } else {
      filesList.style.display = "none"; // hide if no files
    }
  });
}
function showCustomAlert(message) {
  document.getElementById("alertMessage").textContent = message;
  document.getElementById("alertModal").style.display = "flex";
}

  function closeCustomAlert() {
    document.getElementById("alertModal").style.display = "none";
  }

  // Expose alert helpers globally so inline onclick/other scripts can access them
  window.showCustomAlert = showCustomAlert;
  window.closeCustomAlert = closeCustomAlert;
})();

/* Files Modal - Removed because filesModal element doesn't exist in HTML */
// These functions were causing TypeError: Cannot read properties of null
// Commented out until filesModal is added to HTML structure

/*
function openFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "flex";
    updateFilesDateTime();
  }
}

function closeFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "none";
  }
}

function updateFilesDateTime() {
  const filesDateTime = document.getElementById("filesDateTime");
  if (filesDateTime) {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    filesDateTime.innerHTML = `${dateStr}<br>${timeStr}`;
  }
}

const filesModal = document.getElementById("filesModal");
if (filesModal) {
  filesModal.addEventListener("click", e => {
    if (e.target.id === "filesModal") closeFiles();
  });
}
*/

/* Switch tabs - Removed because .file-tabs elements don't exist in HTML */
// These selectors were causing potential errors
// Commented out until file-tabs are added to HTML structure

/*
document.querySelectorAll('.file-tabs .tab').forEach(tab => {
  tab.addEventListener('click', function () {
    document.querySelectorAll('.file-tabs .tab').forEach(t => t.classList.remove('active'));
    this.classList.add('active');

    const target = this.getAttribute('data-tab');
    const uploadedList = document.querySelector('.uploaded-list');
    const downloadableList = document.querySelector('.downloadable-list');
    
    if (uploadedList) uploadedList.style.display = target === "uploaded" ? "block" : "none";
    if (downloadableList) downloadableList.style.display = target === "downloadable" ? "block" : "none";
  });
});
*/

/* Save Button - you don‚Äôt have .btn-save in HTML, so I commented this out
const saveBtn = document.querySelector(".btn-save");
if (saveBtn) {
  saveBtn.addEventListener("click", () => {
    const findings = document.getElementById("findings").value.trim();
    const files = Array.from(document.getElementById("inspectionFile").files);
    if (!findings) {
      alert("Inspection Findings are required.");
      return;
    }
    if (files.length === 0) {
      alert("Please attach at least one supporting document.");
      return;
    }

    const payload = {
      assigned_to: "Alberto Nonato Jr.", // Placeholder
      deadline: "29/10/2025",
      lot: "Alley 2 Sta. Catalina, Block 1, Lot 2",
      scope: "Affected lot/s, Measurement of lot/s",
      findings,
      files: files.map(f => f.name)
    };
    console.log("Submitting inspection data:", payload);
    closeComplaint();
  });
}
*/

// Resolved Task function - implements Staff workflow
// When staff clicks Update: last timeline status changes to "Task Completed"
// Complaint then transitions to appear under resolved.html for staff view
async function resolveTask() {
  const findings = document.getElementById("findings").value.trim();
  const files = Array.from(document.getElementById("inspectionFile").files);

  // Validation checks
  if (!findings && files.length === 0) {
      showCustomAlert("Please input inspection findings and attach the supporting documents/evidence of the inspection first.");
      return;
    }
    if (!findings) {
      showCustomAlert("Please input inspection findings first.");
      return;
    }
    if (files.length === 0) {
      showCustomAlert("Please attach the supporting documents or evidence of the inspection first.");
      return;
    }

  // If all validations pass ‚Üí proceed with Task Completed workflow
  const complaintId = getComplaintIdFromURL();
  
  try {
    console.log('[STAFF WORKFLOW] Submitting Task Completed for complaint:', complaintId);
    
    const response = await fetch('/admin/complaints/api/staff_complete_task', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        complaint_id: complaintId,
        action_type: 'Inspection done',
        description: findings,
        files: files.map(f => f.name),
        staff_account_type: currentStaffAccount, // admin.account == 2
        completed_by_staff: true, // Flag to mark this as staff completion
        task_type: 'inspection' // Specify this is inspection completion
        // Note: Removed action_datetime - server will use NOW() for correct local time
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // Update timeline to show completion status
      await refreshTimeline();
      
      // Update resolved counter
      updateResolvedCounter();
      
      // Redirect to staff resolved view (complaint should now appear there)
      window.location.href = '/staff/complaints/resolved';
    } else {
      console.error('Error completing task:', result.error || result.message);
    }
    
  } catch (error) {
    console.error('[STAFF WORKFLOW] Error completing task:', error);
  } finally {
    // Close modal after submission
    closeComplaint();
  }
}

function getComplaintIdFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const id = urlParams.get('id');
  console.log('URL parameters:', window.location.search);
  console.log('Extracted complaint ID:', id);
  return id || '1';
}

// Back button functionality
function goBack() {
  const urlParams = new URLSearchParams(window.location.search);
  const referrer = urlParams.get('referrer');
  
  if (referrer) {
    window.location.href = `/staff/complaints/${referrer}`;
  } else {
    window.location.href = '/staff/complaints/assigned';
  }
}

// Update resolved counter function
function updateResolvedCounter() {
  // Call parent window to refresh stats if available
  if (window.opener && !window.opener.closed) {
    try {
      window.opener.loadStats();
    } catch (e) {
      console.log('Could not update parent stats:', e);
    }
  }
  
  // Also try to update local counter if element exists
  const resolvedElement = document.getElementById('resolved-count');
  if (resolvedElement) {
    const currentCount = parseInt(resolvedElement.textContent) || 0;
    resolvedElement.textContent = currentCount + 1;
  }
}

// Make functions globally available
window.goBack = goBack;
window.updateResolvedCounter = updateResolvedCounter;

// =====================================
// DYNAMIC TIMELINE SYSTEM FOR STAFF
// =====================================

// Timeline management for Staff View
let timelineData = [];
let currentRole = 'staff'; // Staff role for this page
let currentStaffAccount = 2; // Staff account type (admin.account == 2)

// Staff timeline should show real data only - no sample data
// Timeline shows: previously saved status entries from admin up to staff's assigned task
// After Update button clicked: last timeline status changes to "Task Completed"

// Load timeline data from API
async function loadTimelineData() {
  try {
    const complaintId = getComplaintIdFromURL();
    if (!complaintId) {
      console.error('[TIMELINE DEBUG] No complaint ID found');
      return createFallbackData(1);
    }
    
    console.log(`[TIMELINE DEBUG] Loading timeline for complaint ${complaintId} with role ${currentRole}`);
    
    const response = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=staff`, {
      credentials: 'same-origin'
    });
    
    console.log(`[TIMELINE DEBUG] Timeline API response status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Timeline API error: ${response.status} - ${errorText.substring(0, 200)}`);
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('Timeline data received:', data);
    
    // If no timeline data, add a fallback for testing
    if (!data.timeline || data.timeline.length === 0) {
      console.log('No timeline data from API, adding fallback entries');
      return [{
        history_id: 1,
        complaint_id: parseInt(complaintId),
        type_of_action: 'Inspection',
        assigned_to: 'Staff Member',
        description: 'Inspection task assigned to staff member',
        action_datetime: new Date().toISOString(),
        has_file: false,
        file_path: null
      }];
    }
    
    return data.timeline || [];
  } catch (error) {
    console.error('Error loading timeline data:', error);
    return [];
  }
}

// Format date for timeline display
function formatTimelineDate(dateString) {
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'numeric',
      day: 'numeric',
      year: 'numeric'
    });
  } catch (error) {
    return dateString;
  }
}

// Truncate description to one line with ellipsis
function truncateDescription(text, maxLength = 80) {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

// Map action types to standardized timeline status labels - ONLY 7 ALLOWED STATUSES
function mapActionToTimelineStatus(actionType, isCompleted = false, role = 'staff') {
  // STAFF VIEW: Only allowed sequential flow statuses
  const statusMap = {
    'Submitted': 'Submitted a Valid Complaint',
    'Inspection': isCompleted ? 'Inspection done' : 'Inspection',
    'Invitation': isCompleted ? 'Sent Invitation' : 'Send Invitation',
    'Task Completed': 'Task Completed',
    'Resolved': 'Resolved'
  };
  return statusMap[actionType] || actionType;
}

// Generate default messages for actions without descriptions - ONLY 7 ALLOWED STATUSES
function getDefaultMessage(actionType, assignedTo) {
  const timelineStatus = mapActionToTimelineStatus(actionType);
  const messages = {
    'Submitted a Valid Complaint': 'Your complaint has been received and validated',
    'Inspection': `Site inspection assigned to ${assignedTo || 'inspector'}`,
    'Inspection done': `Site inspection completed by ${assignedTo || 'inspector'}`,
    'Send Invitation': `Invitation task assigned to ${assignedTo || 'staff'}`,
    'Sent Invitation': `Invitation sent to involved parties by ${assignedTo || 'staff'}`,
    'Task Completed': `Task completed and passed back to admin`,
    'Resolved': 'Complaint has been resolved'
  };
  return messages[timelineStatus] || `${timelineStatus} - status unknown`;
}

// Filter timeline entries based on user role
function filterEntriesByRole(entries, role) {
  switch (role) {
    case 'admin':
      // Admin sees all entries
      return entries;
      
    case 'staff':
      // Staff sees previously saved status entries from admin up to their assigned task
      // Show ALL entries from admin work PLUS any staff completed tasks
      console.log('[STAFF FILTER] Original entries:', entries);
      const filteredForStaff = entries.filter(entry => {
        // Show all admin entries (account type 1) and staff completed entries
        return entry.admin_account_type === 1 || entry.completed_by_staff === true;
      }).map(entry => {
        // If this is the staff's completed task, show "Task Completed"
        if (entry.completed_by_staff) {
          return {
            ...entry,
            type_of_action: 'Task Completed',
            description: 'Task completed and passed back to admin for further processing'
          };
        }
        return entry;
      });
      console.log('[STAFF FILTER] Filtered entries for staff:', filteredForStaff);
      return filteredForStaff;
      
    case 'complainant':
      // Complainant sees only milestone completions
      const milestones = ['Inspection done', 'Sent Invitation', 'Assessment', 'Resolved'];
      return entries.filter(entry => {
        const status = mapActionToTimelineStatus(entry.type_of_action);
        return milestones.includes(status) || entry.type_of_action === 'Submitted';
      }).map(entry => {
        // Simplify for complainant view
        if (entry.type_of_action === 'Submitted') {
          return {
            ...entry,
            type_of_action: 'Submitted a valid complaint',
            description: 'Your complaint has been received and validated'
          };
        }
        return entry;
      });
      
    default:
      return entries;
  }
}

// Render timeline entries for staff view (real data only)
function renderTimeline(entries) {
  console.log('[STAFF TIMELINE] renderTimeline called with entries:', entries);
  
  const timelineContainer = document.getElementById('complaintTimeline');
  const loadingElement = document.getElementById('timelineLoading');
  
  if (!timelineContainer) {
    console.error('[STAFF TIMELINE] Timeline container not found!');
    return;
  }
  
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  if (!entries || entries.length === 0) {
    console.log('[STAFF TIMELINE] No timeline entries found from database');
    timelineContainer.innerHTML = `
      <div class="timeline-empty" style="text-align: center; padding: 20px; color: #666;">
        <h4>Timeline Status</h4>
        <p>No timeline entries available for this complaint.</p>
        <p><small>Timeline will show once admin assigns tasks and you begin work.</small></p>
      </div>`;
    return;
  }
  
  // Filter entries for staff view: previously saved status entries from admin up to staff's assigned task
  let filteredEntries = filterEntriesByRole(entries, 'staff');
  
  // Sort entries by date (most recent first)
  filteredEntries.sort((a, b) => new Date(b.action_datetime) - new Date(a.action_datetime));
  
    // Generate HTML for timeline entries (copy admin design structure)
    const timelineHTML = filteredEntries.map(entry => {
      const timelineStatus = mapActionToTimelineStatus(entry.type_of_action, false, 'staff');
      const date = formatTimelineDate(entry.action_datetime);
      const description = entry.description ? 
        truncateDescription(entry.description) : 
        getDefaultMessage(entry.type_of_action, entry.assigned_to);
      
      // File download button for files uploaded by staff/admin 
      const fileButton = entry.has_file ? 
        `<button class="file-btn" data-pdf="${entry.file_path || '#'}" onclick="openTimelineFile('${entry.file_path || '#'}')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 10px;">üìÑ Download File</button>` : 
        '';
      
      const assignedTo = entry.assigned_to ? `<span>${entry.assigned_to}</span>` : '';
      
      return `
        <div class="timeline-entry" data-status="${timelineStatus.toLowerCase().replace(/\s+/g, '-')}">
          <h4>${date} - ${timelineStatus} 
            ${fileButton}
            ${assignedTo}
          </h4>
          <p>${description}</p>
        </div>
      `;
    }).join('');  timelineContainer.innerHTML = timelineHTML;
  
  // Re-attach file button event listeners
  attachFileButtonListeners();
}

// Re-attach event listeners to file buttons
function attachFileButtonListeners() {
  document.querySelectorAll('.file-btn').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const pdfPath = this.getAttribute('data-pdf');
      if (pdfPath && pdfPath !== '#') {
        openTimelineFile(pdfPath);
      }
    });
  });
}

// Open timeline file
function openTimelineFile(filePath) {
  if (filePath && filePath !== '#') {
    window.open(filePath, '_blank');
  } else {
    alert('No file available for this entry.');
  }
}

// Refresh timeline data
async function refreshTimeline() {
  try {
    const loadingElement = document.getElementById('timelineLoading');
    if (loadingElement) {
      loadingElement.style.display = 'block';
      loadingElement.textContent = 'Loading timeline...';
    }
    
    console.log('Starting timeline refresh...');
    const entries = await loadTimelineData();
    console.log('Timeline entries loaded:', entries);
    timelineData = entries;
    renderTimeline(entries);
  } catch (error) {
    console.error('Error refreshing timeline:', error);
    const timelineContainer = document.getElementById('complaintTimeline');
    timelineContainer.innerHTML = `<div class="timeline-error" style="text-align: center; padding: 20px; color: #d32f2f;">Error loading timeline: ${error.message}<br>Please check console for details.</div>`;
  }
}

// Removed showFallbackTimeline - staff view uses real database data only

// Check if coming from resolved view and apply readonly state
function checkResolvedState() {
  const referrer = document.referrer;
  if (referrer && referrer.includes('/staff/complaints/resolved')) {
    applyResolvedReadonlyState();
  }
}

// Apply readonly state for resolved complaints from staff resolved view
function applyResolvedReadonlyState() {
  // Hide the Update Status button
  const updateBtn = document.getElementById('updateStatusBtn');
  if (updateBtn) {
    updateBtn.style.display = 'none';
  }
  
  // Gray out all interactive elements
  const modal = document.getElementById('modal');
  if (modal) {
    modal.style.opacity = '0.6';
    modal.style.pointerEvents = 'none';
  }
  
  // Disable all buttons and inputs in the form, but keep back button functional
  const inputs = document.querySelectorAll('input, button, select, textarea');
  inputs.forEach(input => {
    // Skip the back button - keep it functional
    if (input.onclick && input.onclick.toString().includes('goBack')) {
      return;
    }
    input.disabled = true;
    input.style.backgroundColor = '#f5f5f5';
    input.style.color = '#666';
  });
}

// Initialize timeline on page load - load real data only
document.addEventListener('DOMContentLoaded', function() {
  console.log('[STAFF TIMELINE] Page loaded, loading real timeline data from database');
  
  // Check if coming from resolved view first
  checkResolvedState();
  
  // Load real timeline data immediately (no sample data)
  refreshTimeline();
  
  // Apply readonly state if needed (check if function exists)
  if (typeof applyReadonlyState === 'function') {
    applyReadonlyState();
  }
  
  // Also initialize map loading
  console.log('[STAFF MAP] Loading complaint area map');
  loadComplaintMap();
});

// Make timeline functions globally available
window.refreshTimeline = refreshTimeline;

// =====================================
// DYNAMIC AREA MAP SYSTEM FOR STAFF
// =====================================

// Load complaint details including area information
async function loadComplaintMap() {
  try {
    const complaintId = getComplaintIdFromURL();
    if (!complaintId) {
      console.error('No complaint ID found for loading map');
      showMapError();
      return;
    }

    console.log(`[STAFF MAP] Loading area map for complaint ${complaintId}`);
    
    const response = await fetch(`/admin/complaints/api/complaint_details/${complaintId}`, {
      credentials: 'same-origin'
    });

    if (!response.ok) {
      console.error(`Failed to load complaint details: ${response.status}`);
      showMapError();
      return;
    }

    const result = await response.json();
    console.log('[STAFF MAP] Complaint details received:', result);
    
    if (result.success && result.complaint) {
      displayAreaMap(result.complaint);
    } else {
      console.log('[STAFF MAP] No complaint data found in response');
      showMapError();
    }
    
  } catch (error) {
    console.error('[STAFF MAP] Error loading complaint map:', error);
    showMapError();
  }
}

// Display the appropriate area SVG map
async function displayAreaMap(complaint) {
  try {
    if (!complaint.area_code) {
      console.log('[STAFF MAP] No area_code found in complaint data');
      showMapError();
      return;
    }
    
    console.log(`[STAFF MAP] Loading SVG for area: ${complaint.area_code}`);
    
    const svgPath = `/admin/map/svg/${complaint.area_code.toLowerCase()}.svg`;
    const response = await fetch(svgPath);
    
    if (!response.ok) {
      console.error(`SVG file not found: ${svgPath}`);
      showMapError();
      return;
    }
    
    const svgContent = await response.text();
    
    // Hide loading state
    const loadingElement = document.getElementById('mapLoading');
    if (loadingElement) {
      loadingElement.style.display = 'none';
    }
    
    // Show map content
    const mapContent = document.getElementById('mapContent');
    if (mapContent) {
      mapContent.innerHTML = svgContent;
      mapContent.style.display = 'block';
      
      // Apply responsive styling to SVG
      const svgElement = mapContent.querySelector('svg');
      if (svgElement) {
        svgElement.style.width = '100%';
        svgElement.style.height = 'auto';
        svgElement.style.maxHeight = '300px';
      }
    }
    
    console.log(`[STAFF MAP] Successfully loaded area map for ${complaint.area_code}`);
    
  } catch (error) {
    console.error('[STAFF MAP] Error displaying area map:', error);
    showMapError();
  }
}

// Show error state when map cannot be loaded
function showMapError() {
  const loadingElement = document.getElementById('mapLoading');
  const errorElement = document.getElementById('mapError');
  
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  if (errorElement) {
    errorElement.style.display = 'block';
  }
}

// Map loading is now handled in the main DOMContentLoaded event listener above

// Make map functions globally available
window.loadComplaintMap = loadComplaintMap;
window.displayAreaMap = displayAreaMap;
window.showMapError = showMapError;
</script>

</body>
</html>
