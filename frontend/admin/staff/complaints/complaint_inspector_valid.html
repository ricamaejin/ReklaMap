<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.13.1/font/bootstrap-icons.min.css" 
  integrity="sha512-t7Few9xlddEmgd3oKZQahkNI4dS6l80+eGEzFQiqtyVYdvcSG2D3Iub77R20BdotfRPA9caaRkg1tyaJiPmO0g==" 
  crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/png" href="/images/logo.png">
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/complainants.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/staff/complaints/assigned" class="nav-item active">Complaints</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <header class="header">
      <div class="header-content">
        <div class="header-left">
          <button class="back-arrow" onclick="goBack()" title="Back to Complaints">‚Üê</button>
          <h1>Complaint</h1>
        </div>
      </div>
    </header>

    <div class="complaint-layout" style="margin-top: 30px;">
      <div class="complaint-form">Complaint form data will load here...</div>

      <!-- Right Panel -->
      <div class="right-panel">
        <!-- Dynamic Area Map for Complaint Details -->
        <div class="map-card" id="mapCard">
          <div class="map-loading" id="mapLoading" style="text-align: center; padding: 40px; color: #666;">
            <i class="bi bi-geo-alt-fill" style="font-size: 2em; margin-bottom: 10px;"></i><br>
            Loading area map...
          </div>
          <div class="map-content" id="mapContent" style="display: none;"></div>
          <div class="map-error" id="mapError" style="display: none; text-align: center; padding: 40px; color: #999;">
            <i class="bi bi-exclamation-triangle" style="font-size: 2em; margin-bottom: 10px;"></i><br>
            <span>Area map not available</span>
          </div>
        </div>

        <!-- Dynamic Timeline Component for Staff (copied from admin layout) -->
        <!-- TODO BACKEND: Replace static timeline entries with timeline data from DB -->
        <div class="timeline" id="complaintTimeline">
          <div class="timeline-loading" id="timelineLoading" style="text-align: center; padding: 20px; color: #666;">
            Loading timeline...
          </div>
        </div>
        <button class="update-btn" onclick="openComplaint()" id="updateStatusBtn">Update Status</button>
      </div>
    </div>

    <!-- MODAL -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <!-- HEADER -->
    <div class="modal-top">
      <div class="left-content">
        <strong id="assignedTo">Assigned To: Alberto Nonato Jr.</strong>
        <h2 class="modal-title">Inspection</h2>
      </div>
      <div id="datetime">
        <div id="date">21/10/2025</div>
        <div id="time">9:00 AM</div>
      </div>
    </div>

    <!-- FORM BODY -->
    <div class="modal-body">
      <div class="form-group">
        <label>Deadline:</label>
        <input type="text" id="staffDeadline" value="Loading..." readonly />
      </div>

      <div class="form-group">
        <label>Lot to Inspect</label>
        <input type="text" id="staffLocation" value="Loading..." readonly />
      </div>

      <div class="form-group">
        <label>Scope of Inspection:</label>
        <!-- Render non-editable checkboxes representing the scope -->
        <div id="staffScopeContainer" style="padding:6px 0;"></div>
      </div>

      <hr>

      <div class="form-group">
        <label for="findings">Inspection Findings:</label>
        <textarea id="findings" placeholder="Enter inspection findings..."></textarea>
      </div>

      <div class="form-group" style="display:flex; align-items:flex-start; gap:10px;">
        <label style="flex:0 0 150px; font-weight:bold; margin-top:6px;">
          Attach Supporting Documents or Evidence for the Inspection:
        </label>

        <div id="inspectionFileContainer" style="flex:1; display:flex; flex-direction:column; gap:0px;">
          <!-- First file upload row -->
          <div class="fileUp-row">
            <div class="fileUp-top">
              <input type="text" name="inspectionFileDescription[]" placeholder="File type (e.g. Photo, Report)" required>
            </div>
            <div class="fileUp-bottom">
              <input type="file" name="inspectionFiles[]" id="inspectionFile1" style="display:none;"
                onchange="var f=this.files.length?this.files[0].name:'';var s=document.getElementById('inspectionFileName1');s.textContent=f;s.title=f;">
              <button type="button" class="file-upload-btn" onclick="document.getElementById('inspectionFile1').click()">Upload</button>
              <span class="file-name" id="inspectionFileName1"></span>
            </div>
          </div>
        </div>
      </div>

      <!-- Button to add more -->
      <div class="form-group">
        <button class="form-group-button" type="button" onclick="addInspectionFileUpload()">+ Add Another File</button>
      </div>
    <!-- FOOTER -->
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeComplaint()">Cancel</button>
      <button class="btn-save" onclick="resolveTask()">Update</button>
    </div>
  </div>
</div>

<!-- Custom Alert Modal (separate overlay) -->
<div class="modal-overlay" id="alertModal" style="display: none;">
  <div class="warning-modal">
    <div class="warning-header">‚ö†Ô∏è WARNING MESSAGE</div>
    <div class="warning-body">
      <div class="warning-text">
        <p id="alertMessage"></p>
      </div>
    </div>
    <div class="warning-footer">
      <button onclick="closeCustomAlert()">OK</button>
    </div>
  </div>
</div>
  </main>

  <script>
(function () {
  const modal = document.getElementById('modal');
  const dateEl = document.getElementById('datetime');
  const fileInput = document.getElementById("inspectionFile");
  const previewSection = document.getElementById("inspectionFilesPreview");
  const filesList = document.getElementById("inspectionFilesList");
  let interval = null;

  // Update date & time inside Action modal
  function updateComplaintDateTime() {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    dateEl.innerHTML = `${dateStr}<br>${timeStr}`;
  }

  // Render non-editable checked checkboxes for scope list
  function humanizeScopeLabel(key) {
    if (!key) return '';
    // Replace underscores/hyphens and capitalize words
    return key.replace(/[_-]/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }

  function renderScopeList(container, scope) {
    if (!container) return;
    container.innerHTML = '';

    const items = Array.isArray(scope) ? scope : (typeof scope === 'string' && scope.length ? [scope] : []);
    if (!items || items.length === 0) {
      const none = document.createElement('div');
      none.textContent = 'No scope specified';
      none.style.color = '#666';
      container.appendChild(none);
      return;
    }

    // Use the shared CSS classes to match other forms
    const group = document.createElement('div');
    group.className = 'checkbox-group-compact';

    items.forEach(item => {
      const labelText = humanizeScopeLabel(String(item));
      const label = document.createElement('label');
      label.className = 'checkbox-item-compact';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = 'scope[]';
      checkbox.value = String(item);
      checkbox.checked = true;
      checkbox.disabled = true;

      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + labelText));
      group.appendChild(label);
    });

    container.appendChild(group);
  }

  // Load inspection data from database using admin's autofill system
  async function loadInspectionData() {
    try {
      const complaintId = getComplaintIdFromURL();
      if (!complaintId) {
        console.error('No complaint ID found for loading inspection data');
        return;
      }

      console.log(`[STAFF DATA] Loading inspection data for complaint ${complaintId}`);
      
      // Use existing admin autofill endpoint but filter for inspection data
      const response = await fetch(`/admin/complaints/api/staff_inspection_data/${complaintId}`, {
        credentials: 'same-origin'
      });

      if (!response.ok) {
        console.error(`Failed to load inspection data: ${response.status}`);
        // Set fallback values if API fails
        document.getElementById('staffDeadline').value = 'Not assigned yet';
        document.getElementById('staffLocation').value = 'Not assigned yet';
        document.getElementById('staffScope').value = 'Not assigned yet';
        return;
      }

      const result = await response.json();
      console.log('[STAFF DATA] Inspection data received:', result);
      
      // Prefer structured `data` property when present
      const info = result && result.data ? result.data : result;

      console.log('Staff inspection info:', info);
      console.log('Deadline:', info && info.deadline);
      console.log('Location:', info && info.location);
      console.log('Inspector:', info && (info.inspector || info.assigned_to));
      console.log('Scope:', info && info.scope);

      // Fill readonly fields with data from admin assignment
      const deadlineEl = document.getElementById('staffDeadline');
      const locationEl = document.getElementById('staffLocation');
  const scopeContainer = document.getElementById('staffScopeContainer');
      const assignedToEl = document.getElementById('assignedTo');

      if (deadlineEl) {
        deadlineEl.value = (info && info.deadline) ? info.deadline : 'No deadline set';
      }

      if (locationEl) {
        locationEl.value = (info && info.location) ? info.location : 'No location specified';
      }

      if (scopeContainer) {
        const scopeVal = info && info.scope;
        renderScopeList(scopeContainer, scopeVal);
      }

      // Update assigned inspector text if element exists
      if (assignedToEl) {
        const inspectorName = (info && (info.inspector || info.assigned_to)) || 'Not assigned';
        assignedToEl.textContent = `Assigned To: ${inspectorName}`;
      }
      
    } catch (error) {
      console.error('[STAFF DATA] Error loading inspection data:', error);
      // Set error values
      document.getElementById('staffDeadline').value = 'Error loading data';
      document.getElementById('staffLocation').value = 'Error loading data';
      document.getElementById('staffScope').value = 'Error loading data';
    }
  }

  // Check if page is in readonly mode (resolved complaints)
  function isReadonlyMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('readonly') === 'true';
  }

  // Open Action modal directly and load inspection data
  function openComplaint() {
    // Check if in readonly mode
    if (isReadonlyMode()) {
      alert('This complaint has been resolved and cannot be modified.');
      return;
    }
    
    modal.style.display = 'flex';
    updateComplaintDateTime();
    if (!interval) interval = setInterval(updateComplaintDateTime, 1000);
    
    // Load inspection assignment data from database
    loadInspectionData();
  }

  function closeComplaint() {
    modal.style.display = 'none';
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  }

  modal.addEventListener('click', e => {
    if (e.target === modal) closeComplaint();
  });

  window.openComplaint = openComplaint;
  window.closeComplaint = closeComplaint;
  window.updateComplaintDateTime = updateComplaintDateTime;

  // Removed duplicate function - using the one above that works with proper element IDs

  // File upload preview
if (fileInput) {
  fileInput.addEventListener("change", function () {
    filesList.innerHTML = "";
    const files = Array.from(this.files);

    if (files.length > 0) {
      filesList.style.display = "block"; // show list only if files uploaded
      files.forEach(file => {
        const fileRow = document.createElement("div");
        fileRow.className = "file-item";
        fileRow.textContent = file.name;
        filesList.appendChild(fileRow);
      });
    } else {
      filesList.style.display = "none"; // hide if no files
    }
  });
}
function showCustomAlert(message) {
  document.getElementById("alertMessage").textContent = message;
  document.getElementById("alertModal").style.display = "flex";
}

  function closeCustomAlert() {
    document.getElementById("alertModal").style.display = "none";
  }

  // Expose alert helpers globally so inline onclick/other scripts can access them
  window.showCustomAlert = showCustomAlert;
  window.closeCustomAlert = closeCustomAlert;
})();

/* Files Modal - Removed because filesModal element doesn't exist in HTML */
// These functions were causing TypeError: Cannot read properties of null
// Commented out until filesModal is added to HTML structure

/*
function openFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "flex";
    updateFilesDateTime();
  }
}

function closeFiles() {
  const modal = document.getElementById("filesModal");
  if (modal) {
    modal.style.display = "none";
  }
}

function updateFilesDateTime() {
  const filesDateTime = document.getElementById("filesDateTime");
  if (filesDateTime) {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'short', year: 'numeric', month: 'long', day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    filesDateTime.innerHTML = `${dateStr}<br>${timeStr}`;
  }
}

const filesModal = document.getElementById("filesModal");
if (filesModal) {
  filesModal.addEventListener("click", e => {
    if (e.target.id === "filesModal") closeFiles();
  });
}
*/

/* Switch tabs - Removed because .file-tabs elements don't exist in HTML */
// These selectors were causing potential errors
// Commented out until file-tabs are added to HTML structure

/*
document.querySelectorAll('.file-tabs .tab').forEach(tab => {
  tab.addEventListener('click', function () {
    document.querySelectorAll('.file-tabs .tab').forEach(t => t.classList.remove('active'));
    this.classList.add('active');

    const target = this.getAttribute('data-tab');
    const uploadedList = document.querySelector('.uploaded-list');
    const downloadableList = document.querySelector('.downloadable-list');
    
    if (uploadedList) uploadedList.style.display = target === "uploaded" ? "block" : "none";
    if (downloadableList) downloadableList.style.display = target === "downloadable" ? "block" : "none";
  });
});
*/

/* Save Button - you don‚Äôt have .btn-save in HTML, so I commented this out
const saveBtn = document.querySelector(".btn-save");
if (saveBtn) {
  saveBtn.addEventListener("click", () => {
    const findings = document.getElementById("findings").value.trim();
    const files = Array.from(document.getElementById("inspectionFile").files);
    if (!findings) {
      alert("Inspection Findings are required.");
      return;
    }
    if (files.length === 0) {
      alert("Please attach at least one supporting document.");
      return;
    }

    const payload = {
      assigned_to: "Alberto Nonato Jr.", // Placeholder
      deadline: "29/10/2025",
      lot: "Alley 2 Sta. Catalina, Block 1, Lot 2",
      scope: "Affected lot/s, Measurement of lot/s",
      findings,
      files: files.map(f => f.name)
    };
    console.log("Submitting inspection data:", payload);
    closeComplaint();
  });
}
*/

// Resolved Task function - implements Staff workflow
// When staff clicks Update: last timeline status changes to "Task Completed"
// Complaint then transitions to appear under resolved.html for staff view
async function resolveTask() {
  const findings = document.getElementById("findings").value.trim();
  const files = Array.from(document.getElementById("inspectionFile").files);

  // Validation checks
  if (!findings && files.length === 0) {
      showCustomAlert("Please input inspection findings and attach the supporting documents/evidence of the inspection first.");
      return;
    }
    if (!findings) {
      showCustomAlert("Please input inspection findings first.");
      return;
    }
    if (files.length === 0) {
      showCustomAlert("Please attach the supporting documents or evidence of the inspection first.");
      return;
    }

  // If all validations pass ‚Üí proceed with Task Completed workflow
  const complaintId = getComplaintIdFromURL();
  
  try {
    console.log('[STAFF WORKFLOW] Submitting Task Completed for complaint:', complaintId);
    
    const response = await fetch('/admin/complaints/api/staff_complete_task', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        complaint_id: complaintId,
        action_type: 'Inspection done',
        description: findings,
        files: files.map(f => f.name),
        staff_account_type: currentStaffAccount, // admin.account == 2
        completed_by_staff: true, // Flag to mark this as staff completion
        task_type: 'inspection' // Specify this is inspection completion
        // Note: Removed action_datetime - server will use NOW() for correct local time
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // Update timeline to show completion status
      await refreshTimeline();
      
      // Update resolved counter
      updateResolvedCounter();
      
      // Redirect to staff resolved view (complaint should now appear there)
      window.location.href = '/staff/complaints/resolved';
    } else {
      console.error('Error completing task:', result.error || result.message);
    }
    
  } catch (error) {
    console.error('[STAFF WORKFLOW] Error completing task:', error);
  } finally {
    // Close modal after submission
    closeComplaint();
  }
}

function getComplaintIdFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const id = urlParams.get('id');
  console.log('URL parameters:', window.location.search);
  console.log('Extracted complaint ID:', id);
  return id || null;
}

// Back button functionality
function goBack() {
  const urlParams = new URLSearchParams(window.location.search);
  const referrer = urlParams.get('referrer');
  
  if (referrer) {
    window.location.href = `/staff/complaints/${referrer}`;
  } else {
    window.location.href = '/staff/complaints/assigned';
  }
}

// Update resolved counter function
function updateResolvedCounter() {
  // Call parent window to refresh stats if available
  if (window.opener && !window.opener.closed) {
    try {
      window.opener.loadStats();
    } catch (e) {
      console.log('Could not update parent stats:', e);
    }
  }
  
  // Also try to update local counter if element exists
  const resolvedElement = document.getElementById('resolved-count');
  if (resolvedElement) {
    const currentCount = parseInt(resolvedElement.textContent) || 0;
    resolvedElement.textContent = currentCount + 1;
  }
}

// Make functions globally available
window.goBack = goBack;
window.updateResolvedCounter = updateResolvedCounter;

// =====================================
// DYNAMIC TIMELINE SYSTEM FOR STAFF
// =====================================

// Timeline management for Staff View
let timelineData = [];
let currentRole = 'staff'; // Staff role for this page
let currentStaffAccount = 2; // Staff account type (admin.account == 2)

// Staff timeline should show real data only - no sample data
// Timeline shows: previously saved status entries from admin up to staff's assigned task
// After Update button clicked: last timeline status changes to "Task Completed"

// Load timeline data from API
async function loadTimelineData() {
  try {
    const complaintId = getComplaintIdFromURL();
    if (!complaintId) {
      console.error('[TIMELINE DEBUG] No complaint ID found');
      return createFallbackData(1);
    }
    
    console.log(`[TIMELINE DEBUG] Loading timeline for complaint ${complaintId} with role ${currentRole}`);
    
    const response = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=staff`, {
      credentials: 'same-origin'
    });
    
    console.log(`[TIMELINE DEBUG] Timeline API response status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Timeline API error: ${response.status} - ${errorText.substring(0, 200)}`);
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('Timeline data received:', data);
    
    // If no timeline data, add a fallback for testing
    if (!data.timeline || data.timeline.length === 0) {
      console.log('No timeline data from API, adding fallback entries');
      return [{
        history_id: 1,
        complaint_id: parseInt(complaintId),
        type_of_action: 'Inspection',
        assigned_to: 'Staff Member',
        description: 'Inspection task assigned to staff member',
        action_datetime: new Date().toISOString(),
        has_file: false,
        file_path: null
      }];
    }
    
    return data.timeline || [];
  } catch (error) {
    console.error('Error loading timeline data:', error);
    return [];
  }
}

// Format date and time for timeline display
function formatTimelineDate(dateString) {
  try {
    const date = new Date(dateString);
    const dateStr = date.toLocaleDateString('en-US', {
      month: 'numeric', day: 'numeric', year: 'numeric'
    });
    const timeStr = date.toLocaleTimeString('en-US', {
      hour: 'numeric', minute: '2-digit', hour12: true
    });
    return `${dateStr} | ${timeStr}`;
  } catch (error) {
    return dateString;
  }
}

// Truncate description to one line with ellipsis
function truncateDescription(text, maxLength = 80) {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

// Map action types to standardized timeline status labels - ONLY 7 ALLOWED STATUSES
function mapActionToTimelineStatus(actionType, isCompleted = false, role = 'staff') {
  // STAFF VIEW: Only allowed sequential flow statuses
  const statusMap = {
    'Submitted': 'Submitted a Valid Complaint',
    'Inspection': isCompleted ? 'Inspection done' : 'Inspection',
    'Invitation': isCompleted ? 'Sent Invitation' : 'Send Invitation',
    'Task Completed': 'Task Completed',
    'Resolved': 'Resolved'
  };
  return statusMap[actionType] || actionType;
}

// Generate default messages for actions without descriptions - ONLY 7 ALLOWED STATUSES
function getDefaultMessage(actionType, assignedTo) {
  const timelineStatus = mapActionToTimelineStatus(actionType);
  const messages = {
    'Submitted a Valid Complaint': 'Your complaint has been received and validated',
    'Inspection': `Site inspection assigned to ${assignedTo || 'inspector'}`,
    'Inspection done': `Site inspection completed by ${assignedTo || 'inspector'}`,
    'Send Invitation': `Invitation task assigned to ${assignedTo || 'staff'}`,
    'Sent Invitation': `Invitation sent to involved parties by ${assignedTo || 'staff'}`,
    'Task Completed': `Task completed and passed back to admin`,
    'Resolved': 'Complaint has been resolved'
  };
  return messages[timelineStatus] || `${timelineStatus} - status unknown`;
}

// Filter timeline entries based on user role
function filterEntriesByRole(entries, role) {
  switch (role) {
    case 'admin':
      // Admin sees all entries
      return entries;
      
    case 'staff':
      // Staff sees previously saved status entries from admin up to their assigned task
      // Show ALL entries from admin work PLUS any staff completed tasks
      console.log('[STAFF FILTER] Original entries:', entries);
      const filteredForStaff = entries.filter(entry => {
        // Show all admin entries (account type 1) and staff completed entries
        return entry.admin_account_type === 1 || entry.completed_by_staff === true;
      }).map(entry => {
        // If this is the staff's completed task, show "Task Completed"
        if (entry.completed_by_staff) {
          return {
            ...entry,
            type_of_action: 'Task Completed',
            description: 'Task completed and passed back to admin for further processing'
          };
        }
        return entry;
      });
      console.log('[STAFF FILTER] Filtered entries for staff:', filteredForStaff);
      return filteredForStaff;
      
    case 'complainant':
      // Complainant sees only milestone completions
      const milestones = ['Inspection done', 'Sent Invitation', 'Assessment', 'Resolved'];
      return entries.filter(entry => {
        const status = mapActionToTimelineStatus(entry.type_of_action);
        return milestones.includes(status) || entry.type_of_action === 'Submitted';
      }).map(entry => {
        // Simplify for complainant view
        if (entry.type_of_action === 'Submitted') {
          return {
            ...entry,
            type_of_action: 'Submitted a valid complaint',
            description: 'Your complaint has been received and validated'
          };
        }
        return entry;
      });
      
    default:
      return entries;
  }
}

// Render timeline entries for staff view (real data only)
function renderTimeline(entries) {
  console.log('[STAFF TIMELINE] renderTimeline called with entries:', entries);
  
  const timelineContainer = document.getElementById('complaintTimeline');
  const loadingElement = document.getElementById('timelineLoading');
  
  if (!timelineContainer) {
    console.error('[STAFF TIMELINE] Timeline container not found!');
    return;
  }
  
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  if (!entries || entries.length === 0) {
    console.log('[STAFF TIMELINE] No timeline entries found from database');
    timelineContainer.innerHTML = `
      <div class="timeline-empty" style="text-align: center; padding: 20px; color: #666;">
        <h4>Timeline Status</h4>
        <p>No timeline entries available for this complaint.</p>
        <p><small>Timeline will show once admin assigns tasks and you begin work.</small></p>
      </div>`;
    return;
  }
  
  // Filter entries for staff view: previously saved status entries from admin up to staff's assigned task
  let filteredEntries = filterEntriesByRole(entries, 'staff');
  
  // Sort entries by date (most recent first)
  filteredEntries.sort((a, b) => new Date(b.action_datetime) - new Date(a.action_datetime));
  
    // Generate HTML for timeline entries with new hierarchical layout
    const timelineHTML = filteredEntries.map(entry => {
      const timelineStatus = mapActionToTimelineStatus(entry.type_of_action, false, 'staff');
      const dateTime = formatTimelineDate(entry.action_datetime);
      const assignedTo = entry.assigned_to || '';
      const description = entry.description ? 
        truncateDescription(entry.description) : 
        getDefaultMessage(entry.type_of_action, entry.assigned_to);
      
      // File download button for files uploaded by staff/admin 
      const fileButton = entry.has_file ? 
        `<button class="file-btn" data-pdf="${entry.file_path || '#'}" onclick="openTimelineFile('${entry.file_path || '#'}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-left: 10px;">üìÑ File</button>` : 
        '';
      
      // Determine if this entry should be clickable for preview (only staff-completed actions)
      const isPreviewable = ['Inspection done'].includes(timelineStatus);
      const clickableClass = isPreviewable ? 'timeline-clickable' : '';
      const clickHandler = isPreviewable ? `onclick="showTimelinePreview('${entry.history_id}', '${entry.type_of_action}')"` : '';
      
      return `
        <div class="timeline-entry ${clickableClass}" data-status="${timelineStatus.toLowerCase().replace(/\s+/g, '-')}" ${clickHandler} style="${isPreviewable ? 'cursor: pointer;' : ''}">
          <h4 style="font-size: 16px; margin: 0 0 5px 0;">${timelineStatus}</h4>
          <div style="font-size: 13px; color: #666; margin-bottom: 3px;">${dateTime}</div>
          <div style="font-size: 13px; color: #333; margin-bottom: 5px;">${assignedTo}${fileButton}</div>
          <div style="font-size: 12px; color: #555; line-height: 1.4;">${description}</div>
        </div>
      `;
    }).join('');  timelineContainer.innerHTML = timelineHTML;
  
  // Re-attach file button event listeners
  attachFileButtonListeners();
}

// Re-attach event listeners to file buttons
function attachFileButtonListeners() {
  document.querySelectorAll('.file-btn').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const pdfPath = this.getAttribute('data-pdf');
      if (pdfPath && pdfPath !== '#') {
        openTimelineFile(pdfPath);
      }
    });
  });
}

// Open timeline file
function openTimelineFile(filePath) {
  if (filePath && filePath !== '#') {
    window.open(filePath, '_blank');
  } else {
    alert('No file available for this entry.');
  }
}

// Refresh timeline data
async function refreshTimeline() {
  try {
    const loadingElement = document.getElementById('timelineLoading');
    if (loadingElement) {
      loadingElement.style.display = 'block';
      loadingElement.textContent = 'Loading timeline...';
    }
    
    console.log('Starting timeline refresh...');
    const entries = await loadTimelineData();
    console.log('Timeline entries loaded:', entries);
    timelineData = entries;
    renderTimeline(entries);
  } catch (error) {
    console.error('Error refreshing timeline:', error);
    const timelineContainer = document.getElementById('complaintTimeline');
    timelineContainer.innerHTML = `<div class="timeline-error" style="text-align: center; padding: 20px; color: #d32f2f;">Error loading timeline: ${error.message}<br>Please check console for details.</div>`;
  }
}

// Removed showFallbackTimeline - staff view uses real database data only

// Check if coming from resolved view and apply readonly state
function checkResolvedState() {
  const referrer = document.referrer;
  if (referrer && referrer.includes('/staff/complaints/resolved')) {
    applyResolvedReadonlyState();
  }
}

// Apply readonly state for resolved complaints from staff resolved view
function applyResolvedReadonlyState() {
  // Hide the Update Status button
  const updateBtn = document.getElementById('updateStatusBtn');
  if (updateBtn) {
    updateBtn.style.display = 'none';
  }
  
  // Gray out all interactive elements
  const modal = document.getElementById('modal');
  if (modal) {
    modal.style.opacity = '0.6';
    modal.style.pointerEvents = 'none';
  }
  
  // Disable all buttons and inputs in the form, but keep back button functional
  const inputs = document.querySelectorAll('input, button, select, textarea');
  inputs.forEach(input => {
    // Skip the back button - keep it functional
    if (input.onclick && input.onclick.toString().includes('goBack')) {
      return;
    }
    input.disabled = true;
    input.style.backgroundColor = '#f5f5f5';
    input.style.color = '#666';
  });
}

// Initialize timeline on page load - load real data only
document.addEventListener('DOMContentLoaded', function() {
  console.log('[STAFF TIMELINE] Page loaded, loading real timeline data from database');
  
  // Check if coming from resolved view first
  checkResolvedState();
  
  // Load real timeline data immediately (no sample data)
  refreshTimeline();
  
  // Apply readonly state if needed (check if function exists)
  if (typeof applyReadonlyState === 'function') {
    applyReadonlyState();
  }
  
  // Also initialize map loading
  console.log('[STAFF MAP] Loading complaint area map');
  loadComplaintMap();
});

// Make timeline functions globally available
window.refreshTimeline = refreshTimeline;

// =====================================
// DYNAMIC AREA MAP SYSTEM FOR STAFF
// =====================================

// Load complaint details including area information
async function loadComplaintMap() {
  try {
    const complaintId = getComplaintIdFromURL();
    if (!complaintId) {
      console.error('No complaint ID found for loading map');
      showMapError();
      return;
    }

    console.log(`[STAFF MAP] Loading area map for complaint ${complaintId}`);
    
    const response = await fetch(`/admin/complaints/api/complaint_details/${complaintId}`, {
      credentials: 'same-origin'
    });

    if (!response.ok) {
      console.error(`Failed to load complaint details: ${response.status}`);
      showMapError();
      return;
    }

    const result = await response.json();
    console.log('[STAFF MAP] Complaint details received:', result);
    
    if (result.success && result.complaint) {
      displayAreaMap(result.complaint);
    } else {
      console.log('[STAFF MAP] No complaint data found in response');
      showMapError();
    }
    
  } catch (error) {
    console.error('[STAFF MAP] Error loading complaint map:', error);
    showMapError();
  }
}

// Display the appropriate area SVG map
async function displayAreaMap(complaint) {
  try {
    if (!complaint.area_code) {
      console.log('[STAFF MAP] No area_code found in complaint data');
      showMapError();
      return;
    }
    
    console.log(`[STAFF MAP] Loading SVG for area: ${complaint.area_code}`);
    
    const svgPath = `/admin/map/svg/${complaint.area_code.toLowerCase()}.svg`;
    const response = await fetch(svgPath);
    
    if (!response.ok) {
      console.error(`SVG file not found: ${svgPath}`);
      showMapError();
      return;
    }
    
    const svgContent = await response.text();
    
    // Hide loading state
    const loadingElement = document.getElementById('mapLoading');
    if (loadingElement) {
      loadingElement.style.display = 'none';
    }
    
    // Show map content
    const mapContent = document.getElementById('mapContent');
    if (mapContent) {
      mapContent.innerHTML = svgContent;
      mapContent.style.display = 'block';
      
      // Apply responsive styling to SVG
      const svgElement = mapContent.querySelector('svg');
      if (svgElement) {
        svgElement.style.width = '100%';
        svgElement.style.height = 'auto';
        svgElement.style.maxHeight = '300px';
      }
    }
    
    console.log(`[STAFF MAP] Successfully loaded area map for ${complaint.area_code}`);
    
  } catch (error) {
    console.error('[STAFF MAP] Error displaying area map:', error);
    showMapError();
  }
}

// Show error state when map cannot be loaded
function showMapError() {
  const loadingElement = document.getElementById('mapLoading');
  const errorElement = document.getElementById('mapError');
  
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  if (errorElement) {
    errorElement.style.display = 'block';
  }
}

// Map loading is now handled in the main DOMContentLoaded event listener above

// =====================================
// TIMELINE PREVIEW FUNCTIONALITY FOR STAFF
// =====================================

// Enhanced preview function for staff - shows detailed modal with edit capability
async function showTimelinePreview(historyId, actionType) {
  try {
    console.log(`[STAFF TIMELINE PREVIEW] Opening preview for history ID: ${historyId}, action: ${actionType}`);
    
    // Fetch the timeline entry details
    const response = await fetch(`/admin/complaints/api/timeline_entry/${historyId}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    if (!data.success) {
      throw new Error(data.message || 'Failed to fetch timeline entry');
    }
    
    const entry = data.entry;
    
    // For "Inspection done" actions, allow staff to edit their own completed work
    if (actionType.toLowerCase().includes('inspection done') || actionType.toLowerCase().includes('inspection')) {
      // Pre-populate the modal with the saved data and open it in edit mode
      const details = typeof entry.details === 'string' ? JSON.parse(entry.details) : entry.details;
      
      // Populate the inspection modal fields
      if (details.findings) {
        const findingsEl = document.getElementById('findings');
        if (findingsEl) findingsEl.value = details.findings;
      }
      
      if (details.deadline) {
        const deadlineEl = document.getElementById('staffDeadline');
        if (deadlineEl) deadlineEl.value = details.deadline;
      }
      
      if (details.location) {
        const locationEl = document.getElementById('staffLocation');
        if (locationEl) locationEl.value = details.location;
      }
      
      if (details.scope) {
        const scopeContainer = document.getElementById('staffScopeContainer');
        if (scopeContainer) renderScopeList(scopeContainer, details.scope);
      }
      
      // Open the modal for editing
      openComplaint();
      
    } else {
      // For other actions, show a simple alert
      showCustomAlert(`Timeline Entry Details:\n\nAction: ${actionType}\nEntry ID: ${historyId}\n\nCompleted by staff.`);
    }
    
  } catch (error) {
    console.error('[STAFF TIMELINE PREVIEW] Error:', error);
    showCustomAlert('Error loading timeline entry details: ' + error.message);
  }
}

// Add CSS for clickable timeline entries
const style = document.createElement('style');
style.textContent = `
  .timeline-clickable:hover {
    background-color: #f8f9fa !important;
    border-left-color: #007bff !important;
    transform: translateX(2px);
    transition: all 0.2s ease;
  }
  .timeline-clickable {
    transition: all 0.2s ease;
  }
`;
document.head.appendChild(style);

// Make functions globally available
window.showTimelinePreview = showTimelinePreview;

// Make map functions globally available
window.loadComplaintMap = loadComplaintMap;
window.displayAreaMap = displayAreaMap;
window.showMapError = showMapError;

let inspectionFileCount = 1;
function addInspectionFileUpload() {
  inspectionFileCount++;
  const container = document.getElementById("inspectionFileContainer");
  const fileInputId = "inspectionFile" + inspectionFileCount;
  const fileNameId = "inspectionFileName" + inspectionFileCount;

  const div = document.createElement("div");
  div.className = "fileUp-row";
  div.innerHTML = `
    <div class="fileUp-top">
      <input type="text" name="inspectionFileDescription[]" placeholder="File type (e.g. Photo, Report)" required>
      <button type="button" class="remove-btn-wit" onclick="this.closest('.fileUp-row').remove()">
        <span class="material-icons">close</span>
      </button>
    </div>
    <div class="fileUp-bottom">
      <input type="file" name="inspectionFiles[]" id="${fileInputId}" style="display:none;"
        onchange="var f=this.files.length?this.files[0].name:'';var s=document.getElementById('${fileNameId}');s.textContent=f;s.title=f;">
      <button type="button" class="file-upload-btn" onclick="document.getElementById('${fileInputId}').click()">Upload</button>
      <span class="file-name" id="${fileNameId}"></span>
    </div>
  `;

  container.appendChild(div);
}


</script>

</body>
</html>
