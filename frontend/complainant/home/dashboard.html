<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/images/logo.png">
    <title>ReklaMap</title>
    <link rel="stylesheet" href="/css/complainants.css">
</head>
<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="logo-section">
            <img src="/images/logo.png" alt="ReklaMap Logo" class="logo">
            <span class="title">
                <span class="blue-text">Rekla</span><span class="green-text">Map</span>
            </span>
        </div>
        <nav class="nav-menu">
            <a href="/complainant/home/dashboard.html" class="nav-item active">Home</a>
            <a href="/complainant/complaints/submitted_complaints.html" class="nav-item">Complaints</a>
        </nav>
    </aside>

    <!-- User Dropdown -->
    <div class="user-dropdown">
        Logged in as: <span class="username" id="username"></span>
        <button class="dropdown-toggle">â–¼</button>
        <div class="dropdown-menu">
            <a href="/complainant/profile/view">View Profile</a>
            <a href="/portal/index.html">Logout</a>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <header class="main-header">
            <h1>National Government Center Areas</h1>
            <p>
                RA 9207, passed in 2003, authorized the disposition of 422 hectares in the <br>
                NGC, granting land ownership to 5,678 residents of Barangay Holy Spirit
                and other nearby communities.
            </p>
        </header>

        <!-- Status Card -->
        <section class="status-card">
            <div class="card-inner">
                <!-- CASE 1: No Complaint Yet -->
                <p class="status-description">
                    ReklaMap is connected to the Urban Settlement Assistance Department, making it easy for you to report and track land-related complaints. Whether it's a boundary issue, land misuse, or unauthorized activity, your complaint goes straight to the right authorities for quick action.
                </p>
                <br>
                <div class="status-header">Status</div>

                <!-- CASE 1: No Complaint Yet -->
                <div class="no-complaint">
                    <p>No complaint yet.</p>
                </div>

                <!-- CASE 2: Complaint Exists -->
                <div class="complaint-list hidden">
                    <!-- Dynamically populated complaint items will go here -->
                </div>
                
                <!-- Single Add Complaint button section -->
                <div class="add-complaint-section" style="display: none; text-align: center; margin-top: 20px;">
                    <button class="add-btn" onclick="openComplaint()">Add Complaint</button>
                </div>
            </div>
        </section>
    </main>

    <!-- COMPLAINT MODAL -->
    <div class="modal-overlay" id="modal">
        <div class="modal" style="max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Action</h2>
                <div id="datetime">
                    <div id="date"></div>
                    <div id="time"></div>
                </div>
            </div>
            <hr>
            <div style="flex: 1; overflow-y: auto; padding-right: 10px;">
                <label for="type">Type of Complaint:</label>
                <select id="type" style="width: 98%; height: auto; overflow: hidden;" onchange="updateComplaintDesc()">
                    <option value="" disabled selected hidden>Select Type of Complaint</option>
                    <option value="Lot Dispute">Lot Dispute</option>
                    <option value="Boundary Dispute">Boundary Dispute</option>
                    <option value="Pathway Dispute">Pathway Dispute</option>
                    <option value="Unauthorized Occupation">Unauthorized Occupation</option>
                <!-- Ibalik dating options-->
                </select>

                <!-- Complaint Description -->
                <div class="complaint-desc" id="complaintDesc" style="margin-left: 15px;">
                    <h3 id="descTitle"></h3>
                    <p id="descText" style="white-space: pre-line; max-height: 300px; overflow-y: auto; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;"></p>
                </div>
            </div>

            <div class="modal-footer" style="flex-shrink: 0; margin-top: 10px;">
                <button class="btn-cancel" onclick="closeComplaint()">Cancel</button>
                <button class="btn-save" onclick="goToRegistration()">Select</button>
            </div>
        </div>
    </div>

    <script>
        /* complaint descriptions */
        const complaints = {
            "Lot Dispute": "Refers to situations where there is a conflict involving the lot officially assigned to you. This may include cases where someone else is claiming, occupying, or using your lot; where your name does not appear on the beneficiary list; or where there are errors, overlapping claims, or internal family disputes about who has rightful use or ownership of the lot.\n\nTumutukoy ito sa mga sitwasyon kung saan may alitan o hindi pagkakaunawaan tungkol sa lote na opisyal na naitalaga sa iyo. Kabilang dito ang mga kaso kung saan may ibang taong umaangkin, gumagamit, o nakatira sa iyong lote; kapag hindi nakalista ang iyong pangalan sa talaan ng mga benepisyaryo; o kapag may pagkakamali sa dokumento, magkapatong na pag-aangkin, o alitang pampamilya tungkol sa kung sino ang may karapatang gumamit o magmay-ari ng lote.",
            "Boundary Dispute": "A disagreement between neighboring landowners regarding the exact location of property lines or boundaries, often caused by inaccurate surveys, unclear titles, or encroachments.\n\nHindi pagkakaunawaan sa pagitan ng magkatabing may-ari ng lupa tungkol sa tiyak na lokasyon ng hangganan ng ari-arian, na madalas na dulot ng maling survey, hindi malinaw na titulo, o paglabag sa hangganan.",
            "Pathway Dispute": "Refers to conflicts that arise when residents or neighbors disagree over the use, access, or ownership of a pathway. These disputes typically involve blocked passageways, claims of public access, or disagreements over shared right-of-way.\n\nTumutukoy sa mga alitan na nagaganap kapag hindi nagkakasundo ang mga residente o kapitbahay sa paggamit, pag-access, o pagmamay-ari ng isang daanan. Karaniwan itong kaugnay ng mga hinarang na daanan, pagtatalo kung pampubliko ang access, o hindi pagkakasundo sa karapatang gamitin ang daanan.",
            "Unauthorized Occupation": "Refers to cases where a person is living in, using, or constructing on a lot without legal authority or official assignment. This includes individuals who are not listed as beneficiaries, do not hold valid documents, or have occupied the property without permission from the rightful owner or approval from government housing authorities.\n\nTumutukoy ito sa mga kaso kung saan may taong naninirahan, gumagamit, o nagtatayo sa isang lote nang walang legal na pahintulot o opisyal na pagkakatalaga. Kasama rito ang mga indibidwal na hindi nakalista bilang benepisyaryo, walang wastong dokumento, o sumakop sa lupa nang walang pahintulot mula sa tunay na may-ari o awtorisasyon mula sa ahensyang nangangasiwa sa pabahay ng pamahalaan.",
            "Illegal Construction": "Occurs when a person illegally occupies or builds structures on land that belongs to another individual or the government without proper authorization.\n\nNangyayari kapag ang isang tao ay iligal na sumakop o nagtayo ng mga istruktura sa lupang pagmamay-ari ng ibang tao o ng pamahalaan nang walang tamang pahintulot."
        };

        (function () {
            const modal = document.getElementById('modal');
            const dateEl = document.getElementById('datetime');
            const select = document.getElementById('type');
            const descWrap = document.getElementById('complaintDesc');
            const descTitle = document.getElementById('descTitle');
            const descText = document.getElementById("descText");
            let interval = null;

            function updateComplaintDateTime() {
                const now = new Date();
                const dateStr = now.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'long', day: 'numeric' });
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute:'2-digit', hour12: true });
                dateEl.innerHTML = `${dateStr}<br>${timeStr}`;
            }

            function openComplaint() {
                if (!modal) return;
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');
                updateComplaintDateTime();
                if (!interval) interval = setInterval(updateComplaintDateTime, 1000);
                if (select) {
                    select.value = "";
                    descWrap.style.display = 'none';
                }
            }

            function closeComplaint() {
                if (!modal) return;
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
                if (interval) { clearInterval(interval); interval = null; }
            }

            function updateComplaintDesc() {
                const type = (select && select.value) ? select.value : '';
                if (type && complaints[type]) {
                    descTitle.textContent = type;
                    descText.textContent = complaints[type];
                    descWrap.style.display = 'block';
                } else {
                    descWrap.style.display = 'none';
                    descTitle.textContent = '';
                    descText.textContent = '';
                }
            }

            if (modal) {
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) closeComplaint();
                });
            }

            window.openComplaint = openComplaint;
            window.addComplaint = openComplaint;
            window.closeComplaint = closeComplaint;
            window.updateComplaintDesc = updateComplaintDesc;
        })();
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const dropdown = document.querySelector(".user-dropdown");
            const toggle = dropdown.querySelector(".dropdown-toggle");

            toggle.addEventListener("click", (e) => {
                e.stopPropagation();
                dropdown.classList.toggle("active");
            });

            document.addEventListener("click", () => {
                dropdown.classList.remove("active");
            });
        });
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", async () => {
            try {
                const res = await fetch("/complainant/profile");
                const data = await res.json();
                if (data.success && data.user) {
                    document.getElementById("username").textContent = `${data.user.last_name}, ${data.user.first_name}`;
                } else {
                    document.getElementById("username").textContent = "Guest";
                }
            } catch (err) {
                console.error("Error loading profile:", err);
                document.getElementById("username").textContent = "Guest";
            }
        });
    </script>

    <script>
        async function goToRegistration() {
            const type = document.getElementById("type").value;
            if (!type) {
                alert("Please select a complaint type first.");
                return;
            }
            sessionStorage.setItem("complaintType", type);
            // Use backend to check registration and redirect
            try {
                const res = await fetch("/complainant/start-complaint", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    credentials: "include",
                    body: JSON.stringify({ type })
                });
                if (res.redirected) {
                    window.location.href = res.url;
                } else {
                    const data = await res.json();
                    alert(data.message || "Unable to proceed.");
                }
            } catch (err) {
                alert("Error: " + err);
            }
        }
    </script>

    <script>
    // Show complaint list and manage "Add Complaint" button visibility
    document.addEventListener("DOMContentLoaded", async () => {
        const complaintList = document.querySelector(".complaint-list");
        const noComplaintDiv = document.querySelector(".no-complaint");
        const addComplaintSection = document.querySelector(".add-complaint-section");
        
        // Utility: derive a high-level stage from timeline entries
        function deriveStageFromTimeline(entries) {
            if (!Array.isArray(entries) || entries.length === 0) return "Pending";
            const types = new Set(entries.map(e => (e.type_of_action || e.action_type || "").toLowerCase()));
            if (types.has("resolved")) return "Resolved";
            if (types.has("assessment")) return "Assessment";
            if (types.has("mediation") || types.has("accepted invitation")) return "Mediation";
            if (types.has("sent invitation")) return "Invitation Sent";
            if (types.has("send invitation") || types.has("invitation")) return "Send Invitation";
            if (types.has("inspection done")) return "Inspection done";
            if (types.has("inspection")) return "Inspection";
            if (types.has("submitted")) return "Submitted";
            return "Ongoing";
        }

        // Fetch admin timeline for a complaint (complainant role)
        async function fetchTimeline(complaintId) {
            try {
                // Use admin role to reflect ALL statuses/actions set in admin UI; add cache-busting
                let res = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=admin&_=${Date.now()}`, { credentials: "include" });
                if (res.status === 401 || res.status === 403) {
                    // Fallback to complainant role if admin is blocked
                    res = await fetch(`/admin/complaints/api/timeline/${complaintId}?role=complainant&_=${Date.now()}`, { credentials: "include" });
                }
                const data = await res.json();
                let timeline = (data && data.success) ? (data.timeline || []) : [];
                
                // Apply complainant-focused filtering (same as complaint details page)
                if (timeline.length > 0) {
                    console.log(`[DASHBOARD TIMELINE] Raw entries for complaint ${complaintId}:`, timeline.map(e => ({
                        type: e.type_of_action || e.action_type,
                        datetime: e.action_datetime,
                        description: e.description
                    })));
                    
                    // Filter to meaningful milestones only (no admin noise)
                    const meaningfulActions = ['submitted', 'inspection done', 'sent invitation', 'accepted invitation', 'mediation', 'assessment', 'resolved'];
                    
                    const filteredEntries = timeline.filter(entry => {
                        const type = (entry.type_of_action || entry.action_type || '').toLowerCase().trim();
                        const isSubmitted = type.includes('submitted');
                        const isMeaningfulAction = meaningfulActions.some(action => type.includes(action));
                        return isSubmitted || isMeaningfulAction;
                    });
                    
                    // Deduplicate by type
                    const uniqueEntries = [];
                    const seenTypes = new Set();
                    
                    filteredEntries.forEach(entry => {
                        const type = (entry.type_of_action || entry.action_type || '').toLowerCase().trim();
                        if (!seenTypes.has(type)) {
                            seenTypes.add(type);
                            uniqueEntries.push(entry);
                        }
                    });
                    
                    // If no completed milestones, only show submitted
                    const completedMilestones = uniqueEntries.filter(e => {
                        const type = (e.type_of_action || e.action_type || '').toLowerCase();
                        return !type.includes('submitted') && meaningfulActions.some(action => type.includes(action));
                    });
                    
                    if (completedMilestones.length === 0) {
                        timeline = uniqueEntries.filter(e => (e.type_of_action || e.action_type || '').toLowerCase().includes('submitted'));
                    } else {
                        timeline = uniqueEntries;
                    }
                    
                    console.log(`[DASHBOARD TIMELINE] Filtered to ${timeline.length} meaningful entries for complaint ${complaintId}`);
                }
                
                return timeline;
            } catch (e) {
                console.error("Failed to load timeline:", e);
            }
            return [];
        }

        // Render small timeline under a status item
        function renderMiniTimeline(containerEl, entries) {
            if (!containerEl) return;
            if (!entries || entries.length === 0) {
                containerEl.insertAdjacentHTML("beforeend", `<div class="mini-timeline" style="margin-top:8px;color:#666;">No updates yet.</div>`);
                return;
            }

            // Sort most-recent first
            const sorted = entries.slice().sort((a,b) => new Date(b.action_datetime||0) - new Date(a.action_datetime||0));
            const recent = sorted; // show all entries

            const itemsHtml = recent.map(e => {
                const type = e.type_of_action || e.action_type || "";
                const desc = e.description || type;
                const date = e.action_datetime ? new Date(e.action_datetime).toLocaleDateString('en-US', { month:'short', day:'2-digit' }) : "";
                // color map
                const t = type.toLowerCase();
                let color = "#6c757d"; // default gray
                if (t.includes("submitted")) color = "#17a2b8";
                else if (t.includes("inspection done")) color = "#28a745";
                else if (t.includes("inspection")) color = "#007bff";
                else if (t.includes("sent invitation")) color = "#28a745";
                else if (t.includes("invitation")) color = "#ffc107";
                else if (t.includes("assessment")) color = "#6f42c1";
                else if (t.includes("mediation")) color = "#8e44ad";
                else if (t.includes("resolved")) color = "#20c997";

                return `
                    <div class="mini-timeline-item" style="display:flex;align-items:flex-start;gap:8px;margin:6px 0;">
                        <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin-top:6px;"></span>
                        <div style="flex:1;min-width:0;">
                            <div style="display:flex;justify-content:space-between;gap:8px;">
                                <strong style="font-size:12px;color:${color};text-transform:capitalize;">${type}</strong>
                                <span style="font-size:11px;color:#888;white-space:nowrap;">${date}</span>
                            </div>
                            <div style="font-size:12px;color:#555;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${desc}</div>
                        </div>
                    </div>`;
            }).join("");

            containerEl.insertAdjacentHTML("beforeend", `
                <div class="mini-timeline" style="margin-top:10px;padding-top:8px;border-top:1px solid #eee;max-height:220px;overflow:auto;">
                    ${itemsHtml}
                </div>
            `);
        }
        
        try {
            const res = await fetch("/complainant/complaints/submitted");
            const data = await res.json();
            if (data.success && data.complaints.length > 0) {
                // Filter out resolved complaints from main display
                const activeComplaints = data.complaints.filter(c => {
                    // Check if complaint has "Resolved" status or latest_action indicates resolved
                    const isResolved = c.status === "Resolved" || 
                                     c.is_resolved === true || 
                                     c.complaint_stage === "Resolved" ||
                                     (c.latest_action && c.latest_action.toLowerCase().includes('resolved'));
                    return !isResolved;
                });
                
                if (activeComplaints.length > 0) {
                    // Hide the "No complaint yet" message
                    noComplaintDiv.style.display = "none";
                    
                    // Show the complaint list
                    complaintList.classList.remove("hidden");
                    complaintList.innerHTML = ""; // clear any placeholder

                    // Show only the most recent active complaint (API is already sorted desc by date)
                    const latest = activeComplaints[0];
                if (latest) {
                    const statusItem = document.createElement("div");
                    statusItem.classList.add("status-item", "clickable");
                    statusItem.setAttribute("role", "button");
                    statusItem.setAttribute("tabindex", "0");
                    statusItem.setAttribute("aria-label", `Open ${latest.status} ${latest.type} complaint from ${latest.created_at}`);

                    // color-code by status (match submitted_complaints)
                    const statusLower = (latest.status || "").toLowerCase();
                    if (statusLower === "valid") {
                        statusItem.classList.add("valid");
                    } else if (statusLower === "invalid") {
                        statusItem.classList.add("invalid");
                    }

                    statusItem.innerHTML = `
                        <span class="dot"></span>
                        <div class="status-text" style="width:100%">
                            <strong id="headline-${latest.complaint_id}">${latest.created_at} - Submitted a ${latest.status} Complaint</strong><br>
                            <span>Type: ${latest.type}</span>
                            <div class="stage-pill" style="display:inline-block;margin-left:8px;padding:2px 8px;border-radius:12px;background:#eef3ff;color:#3554d1;font-size:11px;vertical-align:middle;" id="stage-${latest.complaint_id}">Loading stageâ€¦</div>
                            <div id="mini-timeline-${latest.complaint_id}"></div>
                        </div>
                    `;

                    // Click and keyboard access navigate to the complaint preview page
                    const targetUrl = `/complainant/complaint/${latest.complaint_id}`;
                    statusItem.addEventListener("click", () => {
                        window.location.href = targetUrl;
                    });
                    statusItem.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            window.location.href = targetUrl;
                        }
                    });

                    complaintList.appendChild(statusItem);

                    // Fetch and render timeline for this complaint
                    const timeline = await fetchTimeline(latest.complaint_id);
                    // Ensure newest first for both headline and mini timeline
                    let sorted = timeline.slice().sort((a,b) => new Date(b.action_datetime||0) - new Date(a.action_datetime||0));
                    // Ensure a Submitted entry exists (some DBs may not record it in history)
                    const hasSubmitted = sorted.some(e => ((e.type_of_action||e.action_type||'').toLowerCase()==='submitted'));
                    if (!hasSubmitted) {
                        // Use created_at as the submitted date
                        let submittedISO = null;
                        try {
                            const dt = latest.created_at ? new Date(latest.created_at) : null;
                            if (dt && !isNaN(dt)) submittedISO = dt.toISOString();
                        } catch {}
                        sorted.push({
                            type_of_action: 'Submitted',
                            description: 'Submitted a Valid Complaint',
                            action_datetime: submittedISO || new Date().toISOString()
                        });
                        // Resort after push
                        sorted = sorted.sort((a,b) => new Date(b.action_datetime||0) - new Date(a.action_datetime||0));
                    }
                    const stage = deriveStageFromTimeline(sorted);
                    const stageEl = document.getElementById(`stage-${latest.complaint_id}`);
                    if (stageEl) stageEl.textContent = stage;
                    // Update headline to reflect the most recent action
                    const headlineEl = document.getElementById(`headline-${latest.complaint_id}`);
                    if (headlineEl && sorted.length > 0) {
                        const recent = sorted[0];
                        const recentDate = recent.action_datetime ? new Date(recent.action_datetime).toLocaleDateString('en-US', { month:'long', day:'2-digit', year:'numeric' }) : latest.created_at;
                        const recentType = recent.type_of_action || recent.action_type || 'Update';
                        headlineEl.textContent = `${recentDate} - ${recentType}`;
                    }
                    const containerEl = document.getElementById(`mini-timeline-${latest.complaint_id}`);
                    // If the complaint is invalid, do not show any timeline at all
                    if ((latest.status || "").toLowerCase() === "invalid") {
                        containerEl.innerHTML = "";
                    } else {
                        // Skip the first (most recent) entry in the timeline to avoid duplication with headline
                        renderMiniTimeline(containerEl, sorted.slice(1));
                    }
                }

                    // Check if user can add another complaint
                    // They can only add if ALL active complaints are invalid or resolved
                    const hasActiveValidComplaint = activeComplaints.some(c => c.status !== "Invalid");
                    
                    if (hasActiveValidComplaint) {
                        // User has valid/ongoing complaints - hide add button
                        addComplaintSection.style.display = "none";
                    } else {
                        // All active complaints are invalid or resolved - show single add button
                        addComplaintSection.style.display = "block";
                    }
                } else {
                    // No active complaints - show the default "No complaint yet" section and single add button
                    noComplaintDiv.style.display = "block";
                    addComplaintSection.style.display = "block";
                }
            } else {
                // No complaints at all - show the default "No complaint yet" section and single add button
                noComplaintDiv.style.display = "block";
                addComplaintSection.style.display = "block";
            }
        } catch (err) {
            console.error("Error loading complaints:", err);
            // On error, show the default "No complaint yet" section
            noComplaintDiv.style.display = "block";
            addComplaintSection.style.display = "none";
        }
    });
    </script>

</body>
</html>