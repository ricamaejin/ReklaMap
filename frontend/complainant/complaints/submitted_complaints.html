<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/images/logo.png" />
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/complainants.css" />
<Style>
  .complaints-container {
  display: flex;              /* two-column layout */
  gap: 20px;
  align-items: flex-start;
}

.complaints-list {
  flex: 1;                    /* left side takes remaining width */
  display: flex;
  flex-direction: column;     /* stack vertically */
  gap: 20px;
}

.complaint-card.valid {
  background: #d8f5d2; /* light green */
  border-left: 5px solid #2e7d32; /* dark green accent */
}

.complaint-card.invalid {
  background: #f8d7da; /* light red */
  border-left: 5px solid #c62828; /* dark red accent */
}


.complaint-card.clickable-card {
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.complaint-card.clickable-card:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.complaint-card.empty {
  background: transparent;
  box-shadow: none;
  padding: 8px;
  color: #666;
}

.dropdown-card {
  width: 300px;               /* right panel */
  padding: 12px;
  border-radius: 8px;
  background: #fafafa;
  box-shadow: 0 2px 6px rgba(0,0,0,0.03);
  flex-shrink: 0;             /* don’t shrink sidebar */
}

.dropdown-content { 
  display: none; 
  max-height: 360px; 
  overflow: auto; 
  padding-top: 10px; 
}
.dropdown-content.show { display: block; }

</Style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo" />
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/complainant/home/dashboard.html" class="nav-item">Home</a>
      <a href="/complainant/complaints/submitted_complaints.html" class="nav-item active">Complaints</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <header class="header">
      <h1>Submitted Complaints</h1>
    </header>

    <div class="tabs">
      <h3 style="color: #083048;">Ongoing Complaint</h3>
    </div>

    <div class="complaints-container">
  <!-- Left column (complaints stacked per row) -->
  <div class="complaints-list">
    <div class="complaint-card empty">
      No complaints submitted yet.
    </div>
  </div>

      <!-- Complaint History Dropdown -->
      <!-- Right column (dropdown history) -->
  <div class="dropdown-card">
    <div class="dropdown-header" style="cursor:pointer;">
      Complaint History
      <span class="arrow"></span>
    </div>
    <div class="dropdown-content">
      No history available.
    </div>
  </div>
</div>
    </div>
  </main>

<script>
document.addEventListener("DOMContentLoaded", async () => {
  const container = document.querySelector(".complaints-container");
  const complaintList = document.querySelector(".complaints-list");
  const emptyCard = complaintList.querySelector(".complaint-card.empty");
  const dropdownCard = container.querySelector(".dropdown-card");
  const dropdownHeader = dropdownCard.querySelector(".dropdown-header");
  const dropdownContent = dropdownCard.querySelector(".dropdown-content");
  const arrow = dropdownHeader.querySelector(".arrow");

  // Toggle history dropdown
  dropdownHeader.addEventListener("click", () => {
    dropdownContent.classList.toggle("show");
    arrow.classList.toggle("rotate");
  });

  try {
    const res = await fetch("/complainant/complaints/submitted");
    if (!res.ok) {
      throw new Error("Network response was not ok: " + res.status);
    }
    const data = await res.json();
    console.log("Fetched complaints:", data);

    if (data && data.success && Array.isArray(data.complaints) && data.complaints.length > 0) {
      if (emptyCard) emptyCard.style.display = "none"; // hide placeholder
      dropdownContent.innerHTML = ""; // clear history placeholder

      // --- Helper: parse date ---
      function parseDateValue(c) {
        // Prefer server-provided timestamp for reliable sorting
        if (c && typeof c.created_at_ts === "number") return c.created_at_ts;
        const v = c && c.created_at ? c.created_at : 0;
        if (!v && v !== 0) return 0;
        if (typeof v === "number") return v;
        if (/^\d+$/.test(String(v))) return parseInt(v, 10);
        const t = Date.parse(String(v));
        return isNaN(t) ? 0 : t;
      }

      // --- Build a stable key and prefer richer entries when duplicates exist ---
      const keyOf = (c) => {
        const ts = parseDateValue(c);
        const t = c?.type ?? c?.type_of_complaint ?? '';
        return c?.complaint_id ? String(c.complaint_id) : `${t}|${ts}`;
      };
      const richness = (c) => {
        const name = c?.person?.name;
        const role = c?.person?.role;
        const block = c?.person?.block;
        let s = 0;
        if (name && String(name).trim().toLowerCase() !== 'unknown') s += 2;
        if (role && String(role).trim()) s += 1;
        if (block && String(block).trim()) s += 1;
        return s;
      };
      const coalescedMap = new Map();
      for (const c of (data.complaints || [])) {
        const k = keyOf(c);
        if (!k) continue;
        const prev = coalescedMap.get(k);
        if (!prev || richness(c) > richness(prev)) {
          coalescedMap.set(k, c);
        }
      }
      const coalesced = Array.from(coalescedMap.values());
      // --- Sort newest → oldest ---
      const sortedComplaints = coalesced.sort((a, b) => parseDateValue(b) - parseDateValue(a));

      // --- Separate active and resolved complaints ---
      const activeComplaints = sortedComplaints.filter(c => {
        const isResolved = c.status === "Resolved" || 
                          c.is_resolved === true || 
                          c.complaint_stage === "Resolved" ||
                          (c.latest_action && c.latest_action.toLowerCase().includes('resolved'));
        return !isResolved;
      });
      const resolvedComplaints = sortedComplaints.filter(c => {
        const isResolved = c.status === "Resolved" || 
                          c.is_resolved === true || 
                          c.complaint_stage === "Resolved" ||
                          (c.latest_action && c.latest_action.toLowerCase().includes('resolved'));
        return isResolved;
      });

      // --- Show ONLY the most recent active complaint in left panel ---
      const mostRecent = activeComplaints[0];
      if (mostRecent) {
        const recentCard = buildComplaintCard(mostRecent);
        complaintList.appendChild(recentCard);
      }

      // --- Show all past active complaints (exclude the currently shown one) and all resolved complaints in history ---
      const excludeKey = mostRecent ? keyOf(mostRecent) : null;
      
      // Add remaining active complaints to history
      activeComplaints
        .filter(c => !excludeKey || keyOf(c) !== excludeKey)
        .forEach((c) => {
          const historyCard = buildComplaintCard(c);
          historyCard.classList.add("history-card"); // optional for styling
          dropdownContent.appendChild(historyCard);
        });
      
      // Add all resolved complaints to history
      resolvedComplaints.forEach((c) => {
        const historyCard = buildComplaintCard(c);
        historyCard.classList.add("history-card", "resolved-complaint"); // optional for styling
        dropdownContent.appendChild(historyCard);
      });

    } else {
      if (emptyCard) emptyCard.style.display = "block";
      dropdownContent.textContent = "No history available.";
    }
  } catch (err) {
    console.error("Error fetching complaints:", err);
    if (emptyCard) emptyCard.style.display = "block";
    dropdownContent.textContent = "Failed to load complaint history.";
  }

  // --- Helper: escape text to avoid HTML injection ---
  function escapeHtml(str) {
    if (!str && str !== 0) return "";
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // --- Helper: Build complaint card (used for main + history) ---
  function buildComplaintCard(c) {
  const complaintId = c.complaint_id ?? "";
  const createdAt = c.created_at ?? "";
  const type = c.type ?? c.type_of_complaint ?? "Complaint";
  const status = (c.status ?? c.state ?? "").toLowerCase(); // normalize for comparison
  const personName = (c.person && c.person.name) || c.q12 || c.person_name || "Unknown";
  const personBlock = (c.person && c.person.block) || (c.property && c.property.block) || c.block || null;
  const personLot = (c.person && c.person.lot) || (c.property && c.property.lot) || c.lot || null;
  const personRole = (c.person && c.person.role) || "";

  // Format block and lot display
  let blockLotDisplay = "";
  if (personBlock && personLot) {
    blockLotDisplay = `Block: ${personBlock}  Lot: ${personLot}`;
  } else if (personBlock) {
    blockLotDisplay = `Block: ${personBlock}`;
  } else if (personLot) {
    blockLotDisplay = `Lot: ${personLot}`;
  } else {
    blockLotDisplay = "Block: N/A  Lot: N/A";
  }

  const card = document.createElement("div");
  card.classList.add("complaint-card", "clickable-card");

  if (complaintId) card.dataset.id = complaintId;

  // ✅ Add color based on validity
  if (status === "valid") {
    card.classList.add("valid");
  } else if (status === "invalid") {
    card.classList.add("invalid");
  }

  card.innerHTML = `
    <h4>${escapeHtml(createdAt)} - ${escapeHtml(type)}</h4>
    <p><strong>Status:</strong> ${escapeHtml(status)}</p>
    <div class="person-box">
      <p><strong>Person Involved:</strong></p>
      <p>Name: ${escapeHtml(personName)}</p>
      <p>${escapeHtml(blockLotDisplay)}</p>
  ${personRole ? `<p>${escapeHtml(personRole)}</p>` : ''}
    </div>
  `;

  // Click handler
  card.addEventListener("click", () => {
    if (card.dataset.id) {
      window.location.href = `/complainant/complaint/${card.dataset.id}`;
    }
  });

  return card;
}

});
</script>



</body>
</html>



