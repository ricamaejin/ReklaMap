<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/images/logo.png" />
  <title>ReklaMap</title>
  <link rel="stylesheet" href="/css/complainants.css" />
  <link rel="stylesheet" href="/css/modal_shared.css" />
<Style>
  .complaints-container {
  display: flex;              /* two-column layout */
  gap: 20px;
  align-items: flex-start;
}

.complaints-list {
  flex: 1;                    /* left side takes remaining width */
  display: flex;
  flex-direction: column;     /* stack vertically */
  gap: 20px;
}

.complaint-card.valid {
  background: #d8f5d2; /* light green */
  border-left: 5px solid #2e7d32; /* dark green accent */
}

.complaint-card.invalid {
  background: #f8d7da; /* light red */
  border-left: 5px solid #c62828; /* dark red accent */
}


.complaint-card.clickable-card {
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.complaint-card.clickable-card:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.complaint-card.empty {
  background: transparent;
  box-shadow: none;
  padding: 8px;
  color: #666;
}

.dropdown-card {
  width: 300px;               /* right panel */
  padding: 12px;
  border-radius: 8px;
  background: #fafafa;
  box-shadow: 0 2px 6px rgba(0,0,0,0.03);
  flex-shrink: 0;             /* don’t shrink sidebar */
}

.dropdown-content { 
  display: none; 
  max-height: 360px; 
  overflow: auto; 
  padding-top: 10px; 
}
.dropdown-content.show { display: block; }

</Style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="logo-section">
      <img src="/images/logo.png" alt="ReklaMap Logo" class="logo" />
      <span class="title"><span class="blue-text">Rekla</span><span class="green-text">Map</span></span>
    </div>
    <nav class="nav-menu">
      <a href="/complainant/home/dashboard.html" class="nav-item">Home</a>
      <a href="/complainant/complaints/submitted_complaints.html" class="nav-item active">Complaints</a>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <header class="header">
      <h1>Submitted Complaints</h1>
    </header>

    <div class="tabs">
      <h3 style="color: #083048;">Ongoing Complaint</h3>
    </div>

    <div class="complaints-container">
  <!-- Left column (complaints stacked per row) -->
  <div class="complaints-list">
    <div class="complaint-card empty">
      No complaints submitted yet.
    </div>
  </div>

      <!-- Complaint History Dropdown -->
      <!-- Right column (dropdown history) -->
  <div class="dropdown-card">
    <div class="dropdown-header" style="cursor:pointer;">
      Complaint History
      <span class="arrow"></span>
    </div>
    <div class="dropdown-content">
      No history available.
    </div>
  </div>
</div>
    </div>
  </main>

<script>
document.addEventListener("DOMContentLoaded", async () => {
  const container = document.querySelector(".complaints-container");
  const complaintList = document.querySelector(".complaints-list");
  const emptyCard = complaintList.querySelector(".complaint-card.empty");
  const dropdownCard = container.querySelector(".dropdown-card");
  const dropdownHeader = dropdownCard.querySelector(".dropdown-header");
  const dropdownContent = dropdownCard.querySelector(".dropdown-content");
  const arrow = dropdownHeader.querySelector(".arrow");

  // Toggle history dropdown
  dropdownHeader.addEventListener("click", () => {
    dropdownContent.classList.toggle("show");
    arrow.classList.toggle("rotate");
  });

  try {
    const res = await fetch("/complainant/complaints/submitted");
    if (!res.ok) {
      throw new Error("Network response was not ok: " + res.status);
    }
    const data = await res.json();
    console.log("Fetched complaints:", data);

    if (data && data.success && Array.isArray(data.complaints) && data.complaints.length > 0) {
      if (emptyCard) emptyCard.style.display = "none"; // hide placeholder
      dropdownContent.innerHTML = ""; // clear history placeholder

      // --- Helper: parse date ---
      function parseDateValue(c) {
        // Prefer server-provided timestamp for reliable sorting
        if (c && typeof c.created_at_ts === "number") return c.created_at_ts;
        const v = c && c.created_at ? c.created_at : 0;
        if (!v && v !== 0) return 0;
        if (typeof v === "number") return v;
        if (/^\d+$/.test(String(v))) return parseInt(v, 10);
        const t = Date.parse(String(v));
        return isNaN(t) ? 0 : t;
      }

      // --- Build a stable key and prefer richer entries when duplicates exist ---
      const keyOf = (c) => {
        const ts = parseDateValue(c);
        const t = c?.type ?? c?.type_of_complaint ?? '';
        return c?.complaint_id ? String(c.complaint_id) : `${t}|${ts}`;
      };
      const richness = (c) => {
        const name = c?.person?.name;
        const role = c?.person?.role;
        const block = c?.person?.block;
        let s = 0;
        if (name && String(name).trim().toLowerCase() !== 'unknown') s += 2;
        if (role && String(role).trim()) s += 1;
        if (block && String(block).trim()) s += 1;
        return s;
      };
      const coalescedMap = new Map();
      for (const c of (data.complaints || [])) {
        const k = keyOf(c);
        if (!k) continue;
        const prev = coalescedMap.get(k);
        if (!prev || richness(c) > richness(prev)) {
          coalescedMap.set(k, c);
        }
      }
      const coalesced = Array.from(coalescedMap.values());
      // --- Sort newest → oldest ---
      const sortedComplaints = coalesced.sort((a, b) => parseDateValue(b) - parseDateValue(a));

      // --- Separate active and resolved/final complaints ---
      const activeComplaints = sortedComplaints.filter(c => {
        const isFinal = c.status === "Resolved" || 
                       c.is_resolved === true || 
                       c.complaint_stage === "Resolved" ||
                       c.complaint_stage === "Unresolved" ||
                       c.complaint_stage === "Out of Jurisdiction" ||
                       (c.latest_action && c.latest_action.toLowerCase().includes('resolved'));
        return !isFinal;
      });
      const resolvedComplaints = sortedComplaints.filter(c => {
        const isFinal = c.status === "Resolved" || 
                       c.is_resolved === true || 
                       c.complaint_stage === "Resolved" ||
                       c.complaint_stage === "Unresolved" ||
                       c.complaint_stage === "Out of Jurisdiction" ||
                       (c.latest_action && c.latest_action.toLowerCase().includes('resolved'));
        return isFinal;
      });

      // --- Show ONLY the most recent active complaint in left panel ---
      const mostRecent = activeComplaints[0];
      if (mostRecent) {
        const recentCard = buildComplaintCard(mostRecent);
        complaintList.appendChild(recentCard);
      }

      // --- Show all past active complaints (exclude the currently shown one) and all resolved complaints in history ---
      const excludeKey = mostRecent ? keyOf(mostRecent) : null;
      
      // Add remaining active complaints to history
      activeComplaints
        .filter(c => !excludeKey || keyOf(c) !== excludeKey)
        .forEach((c) => {
          const historyCard = buildComplaintCard(c);
          historyCard.classList.add("history-card"); // optional for styling
          dropdownContent.appendChild(historyCard);
        });
      
      // Add all resolved complaints to history
      resolvedComplaints.forEach((c) => {
        const historyCard = buildComplaintCard(c);
        historyCard.classList.add("history-card", "resolved-complaint"); // optional for styling
        dropdownContent.appendChild(historyCard);
      });

    } else {
      if (emptyCard) emptyCard.style.display = "block";
      dropdownContent.textContent = "No history available.";
    }
  } catch (err) {
    console.error("Error fetching complaints:", err);
    if (emptyCard) emptyCard.style.display = "block";
    dropdownContent.textContent = "Failed to load complaint history.";
  }

  // --- Helper: escape text to avoid HTML injection ---
  function escapeHtml(str) {
    if (!str && str !== 0) return "";
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // --- Confirmation modal for opening a complaint (shared CSS classes) ---
  const complaintConfirmModal = (function createConfirm() {
    const m = document.createElement('div');
    m.id = 'complaintConfirmModal';
    m.className = 'rk-modal-backdrop';

    const inner = document.createElement('div');
    inner.className = 'rk-modal';
    inner.innerHTML = `
      <div class="rk-modal-header">
        <div class="rk-modal-icon">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z" fill="#1a33a0" opacity="0.12"/><path d="M11 16h2v-2h-2v2zm0-8h2v6h-2V8z" fill="#1a33a0"/></svg>
        </div>
        <p class="rk-modal-title">Open complaint</p>
      </div>
      <p class="rk-modal-body">Do you want to open this complaint? You will be taken to the complaint preview page.</p>
      <div class="rk-modal-actions">
        <button id="complaintConfirmCancel" class="rk-btn-ghost">Cancel</button>
        <button id="complaintConfirmOpen" class="rk-btn-primary">Open</button>
      </div>
    `;

    m.appendChild(inner);
    document.body.appendChild(m);

    let pendingId = null;

    const cancelBtn = m.querySelector('#complaintConfirmCancel');
    const openBtn = m.querySelector('#complaintConfirmOpen');

    cancelBtn.addEventListener('click', () => {
      pendingId = null;
      m.classList.remove('show');
    });
    openBtn.addEventListener('click', () => {
      const id = pendingId;
      pendingId = null;
      m.classList.remove('show');
      if (id) window.location.href = `/complainant/complaint/${id}`;
    });

    // allow clicking outside to cancel
    m.addEventListener('click', (ev) => {
      if (ev.target === m) { pendingId = null; m.classList.remove('show'); }
    });

    return {
      show(id) { pendingId = id; m.classList.add('show'); },
      hide() { pendingId = null; m.classList.remove('show'); }
    };
  })();

  // --- Helper: Build complaint card (used for main + history) ---
  function buildComplaintCard(c) {
  const complaintId = c.complaint_id ?? "";
  const createdAt = c.created_at ?? "";
  // Prefer server-provided epoch (ms) so we can format to the user's local timezone.
  let createdTime = "";
  if (typeof c.created_at_ts === 'number' && c.created_at_ts > 0) {
    try {
      const dt = new Date(Number(c.created_at_ts));
      // Format to HH:MM in user's locale (24-hour when available)
      createdTime = dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (e) {
      createdTime = c.created_time ?? "";
    }
  } else {
    createdTime = c.created_time ?? "";
  }
  const type = c.type ?? c.type_of_complaint ?? "Complaint";
  const status = (c.status ?? c.state ?? "").toLowerCase(); // normalize for comparison
  const complaintStage = c.complaint_stage || "";
  const personName = (c.person && c.person.name) || c.q12 || c.person_name || "Unknown";
  const personBlock = (c.person && c.person.block) || (c.property && c.property.block) || c.block || null;
  const personLot = (c.person && c.person.lot) || (c.property && c.property.lot) || c.lot || null;
  let personRole = (c.person && c.person.role) || "";

  // If API returned a complainant object, prefer that for display of complainant info
  const complainant = c.complainant || null;
  const complainantName = complainant && complainant.name ? complainant.name : (c.registration_name || c.person_name || "");
  const complainantType = complainant && complainant.type ? complainant.type : (c.registration_type || "");
  const complainantHoa = complainant && complainant.hoa ? complainant.hoa : (c.hoa || "");
  const complainantBlock = complainant && (complainant.block || complainant.block===0) ? complainant.block : personBlock;
  const complainantLot = complainant && (complainant.lot || complainant.lot===0) ? complainant.lot : personLot;

  // Determine display status - prioritize complaint_stage for final states
  let displayStatus = status;
  if (complaintStage === "Resolved") {
    displayStatus = "Resolved";
  } else if (complaintStage === "Unresolved") {
    displayStatus = "Unresolved";
  } else if (complaintStage === "Out of Jurisdiction") {
    displayStatus = "Out of Jurisdiction";
  }

  // Format block and lot display consistently as: "Block <n>, Lot <m>" or show N/A
  function hasValue(v) {
    return v !== undefined && v !== null && String(v).trim() !== "";
  }

  const blockLotDisplay = (function(b, l) {
    const bHas = hasValue(b);
    const lHas = hasValue(l);
    if (bHas && lHas) return `Block ${b}, Lot ${l}`;
    if (bHas) return `Block ${b}, Lot: N/A`;
    if (lHas) return `Block: N/A, Lot ${l}`;
    return `Block: N/A, Lot: N/A`;
  })(complainantBlock, complainantLot);

  const card = document.createElement("div");
  card.classList.add("complaint-card", "clickable-card");

  if (complaintId) card.dataset.id = complaintId;

  // ✅ Add color based on complaint stage or validity
  if (complaintStage === "Resolved") {
    card.classList.add("valid"); // Green for resolved
  } else if (complaintStage === "Unresolved") {
    card.classList.add("invalid"); // Red for unresolved
  } else if (complaintStage === "Out of Jurisdiction") {
    card.classList.add("invalid"); // Red for out of jurisdiction
  } else if (status === "valid") {
    card.classList.add("valid");
  } else if (status === "invalid") {
    card.classList.add("invalid");
  }

  // Build details section depending on complaint type
  let detailsHtml = '';
  // Helper to get stored answers for various complaint types (defensive)
  function getAnswer(key) {
    if (!c) return '';
    const tries = [
      c[key],
      (c.answers && c.answers[key]),
      (c.form && c.form[key]),
      (c.data && c.data[key]),
      (c.payload && c.payload[key]),
      (c.details && c.details[key]),
      (c.questionnaire && c.questionnaire[key])
    ];
    for (const t of tries) {
      if (t === undefined || t === null) continue;
      if (Array.isArray(t) && t.length > 0) return t[0];
      if (typeof t === 'string') return t;
      // if object with value property
      if (typeof t === 'object' && t.value) return t.value;
      // fallback to stringify
      try { return String(t); } catch (e) { continue; }
    }
    return '';
  }
  // Helper to build a single opposing party string
  function formatOpposing(op) {
    if (!op) return '';
    const n = escapeHtml(op.name || op.person || op.person_name || 'Unknown');
    const rel = escapeHtml((op.relationship || op.relation || op.role || '').toString().replace(/^Relationship:\s*/i, '').trim());
    const b = op.block || op.b || op.block_no || op.blockNumber || '';
    const l = op.lot || op.l || op.lot_no || op.lotNumber || '';
    let bl = '';
    if (b && l) bl = `B${escapeHtml(b)}-L${escapeHtml(l)}`;
    else if (b) bl = `B${escapeHtml(b)}`;
    else if (l) bl = `L${escapeHtml(l)}`;
    const parts = [];
    if (rel) parts.push(rel);
    if (bl) parts.push(bl);
    return bl || rel ? `${n} (${parts.join(', ')})` : n;
  }

  if (type === 'Lot Dispute') {
    detailsHtml = `
      <p><strong>Complainant:</strong> ${escapeHtml(complainantName || personName)}${complainantType ? ` (${escapeHtml(complainantType)})` : ''}</p>
      <p><strong>Area (HOA):</strong> ${escapeHtml(complainantHoa || '')}${complainantBlock || complainantLot ? `, ${escapeHtml(blockLotDisplay)}` : ''}</p>
      <p><strong>Opposing Party:</strong> ${escapeHtml(personName)}${(personRole && String(personRole).replace(/^Relationship:\s*/i, '').trim()) ? ` (${escapeHtml(String(personRole).replace(/^Relationship:\s*/i, '').trim())})` : ''}</p>
    `;
  } else if (type === 'Boundary Dispute' || /boundary/i.test(type) || type === 'Unauthorized Occupation' || /unauthorized/i.test(type)) {
    // For Boundary Dispute, prefer API-provided opposing_parties array
    const opps = Array.isArray(c.opposing_parties) ? c.opposing_parties : (Array.isArray(c.persons) ? c.persons : []);
    let opposingList = '';
    if (opps && opps.length > 0) {
      const formatted = opps.map(op => formatOpposing(op));
      opposingList = formatted.filter(Boolean).join(', ');
    } else {
      // Fallback: try to use c.person / c.q12 / c.q13
      const fallback = formatOpposing({ name: c.person?.name || c.q12 || c.q13 || personName, relationship: c.person?.role || '' });
      opposingList = fallback;
    }

    const oppCount = Array.isArray(opps) ? opps.length : (opposingList ? String(opposingList).split(',').length : 0);
    const oppLabel = oppCount === 1 ? 'Opposing Party' : 'Opposing Parties';
    detailsHtml = `
      <p><strong>Complainant:</strong> ${escapeHtml(complainantName || personName)}${complainantType ? ` (${escapeHtml(complainantType)})` : ''}</p>
      <p><strong>Area (HOA):</strong> ${escapeHtml(complainantHoa || '')}${complainantBlock || complainantLot ? `, ${escapeHtml(blockLotDisplay)}` : ''}</p>
      <p><strong>${oppLabel}:</strong> ${escapeHtml(opposingList)}</p>
    `;
  } else if (type === 'Pathway Dispute' || /pathway/i.test(type)) {
  // Pathway Dispute specific fields: q1 = pathway type, q2 = encroachment
  // Prefer API-provided top-level values (c.q1 / c.q2) then fall back to other locations
  const pathwayType = (c.q1 !== undefined && c.q1 !== null && String(c.q1).trim() !== '') ? c.q1 : (getAnswer('q1') || getAnswer('pathway_type') || getAnswer('type_of_path') || '');
  const encroachment = (c.q2 !== undefined && c.q2 !== null && String(c.q2).trim() !== '') ? c.q2 : (getAnswer('q2') || getAnswer('encroachment') || getAnswer('nature_of_encroachment') || '');

    detailsHtml = `
      <p><strong>Complainant:</strong> ${escapeHtml(complainantName || personName)}${complainantType ? ` (${escapeHtml(complainantType)})` : ''}</p>
      <p><strong>Area (HOA):</strong> ${escapeHtml(complainantHoa || '')}${complainantBlock || complainantLot ? `, ${escapeHtml(blockLotDisplay)}` : ''}</p>
      <p><strong>Pathway Type:</strong> ${escapeHtml(pathwayType)}</p>
      <p><strong>Encroachment:</strong> ${escapeHtml(encroachment)}</p>
    `;
  } else {
    detailsHtml = `
      <p><strong>Person Involved:</strong></p>
      <p>Name: ${escapeHtml(personName)}</p>
      <p>${escapeHtml(blockLotDisplay)}</p>
      ${personRole ? `<p>${escapeHtml(personRole)}</p>` : ''}
    `;
  }

  card.innerHTML = `
    <h4>${escapeHtml(type)} - ${escapeHtml(createdAt)}</h4>
    <div style="font-size:0.85em;color:#666;margin-top:4px;">${escapeHtml(createdTime)}</div>
    <p><strong>Status:</strong> ${escapeHtml(complaintStage || displayStatus)}</p>
    <div class="person-box">
      ${detailsHtml}
    </div>
  `;

  // Click handler: show confirmation modal first
  card.addEventListener("click", () => {
    if (card.dataset.id) {
      complaintConfirmModal.show(card.dataset.id);
    }
  });

  return card;
}

});
</script>



</body>
</html>



